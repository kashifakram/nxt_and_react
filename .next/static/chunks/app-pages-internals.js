/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-pages-internals"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-segment.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/metadata/metadata-boundary.js */ \"(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZrYXNoaWYuYWtyYW0lMkZQcm9qZWN0cyUyRm5leHQlMkZtYW51YWwlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZjbGllbnQtcGFnZS5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRmthc2hpZi5ha3JhbSUyRlByb2plY3RzJTJGbmV4dCUyRm1hbnVhbCUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRmNsaWVudC1zZWdtZW50LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGa2FzaGlmLmFrcmFtJTJGUHJvamVjdHMlMkZuZXh0JTJGbWFudWFsJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGZXJyb3ItYm91bmRhcnkuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZrYXNoaWYuYWtyYW0lMkZQcm9qZWN0cyUyRm5leHQlMkZtYW51YWwlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZodHRwLWFjY2Vzcy1mYWxsYmFjayUyRmVycm9yLWJvdW5kYXJ5LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGa2FzaGlmLmFrcmFtJTJGUHJvamVjdHMlMkZuZXh0JTJGbWFudWFsJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRmthc2hpZi5ha3JhbSUyRlByb2plY3RzJTJGbmV4dCUyRm1hbnVhbCUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRnJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZrYXNoaWYuYWtyYW0lMkZQcm9qZWN0cyUyRm5leHQlMkZtYW51YWwlMkZub2RlX21vZHVsZXMlMkZuZXh0JTJGZGlzdCUyRmxpYiUyRm1ldGFkYXRhJTJGbWV0YWRhdGEtYm91bmRhcnkuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxrUEFBcUk7QUFDckk7QUFDQSx3UEFBd0k7QUFDeEk7QUFDQSx3UEFBd0k7QUFDeEk7QUFDQSxrU0FBNko7QUFDN0o7QUFDQSxzUEFBdUk7QUFDdkk7QUFDQSxvUkFBc0o7QUFDdEo7QUFDQSxvUEFBc0kiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQtcGFnZS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC1zZWdtZW50LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9odHRwLWFjY2Vzcy1mYWxsYmFjay9lcnJvci1ib3VuZGFyeS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/lib/metadata/metadata-boundary.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    MetadataBoundary: function() {\n        return MetadataBoundary;\n    },\n    OutletBoundary: function() {\n        return OutletBoundary;\n    },\n    ViewportBoundary: function() {\n        return ViewportBoundary;\n    }\n});\nconst _metadataconstants = __webpack_require__(/*! ./metadata-constants */ \"(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-constants.js\");\n// We use a namespace object to allow us to recover the name of the function\n// at runtime even when production bundling/minification is used.\nconst NameSpace = {\n    [_metadataconstants.METADATA_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    },\n    [_metadataconstants.VIEWPORT_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    },\n    [_metadataconstants.OUTLET_BOUNDARY_NAME]: function(param) {\n        let { children } = param;\n        return children;\n    }\n};\nconst MetadataBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.METADATA_BOUNDARY_NAME.slice(0)];\nconst ViewportBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.VIEWPORT_BOUNDARY_NAME.slice(0)];\nconst OutletBoundary = // We use slice(0) to trick the bundler into not inlining/minifying the function\n// so it retains the name inferred from the namespace object\nNameSpace[_metadataconstants.OUTLET_BOUNDARY_NAME.slice(0)];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL21ldGFkYXRhL21ldGFkYXRhLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiJxREFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGLENBQUMsS0FBS0MsQ0FJTixDQUFDLENBQUM7QUFDRixTQUFTSSxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtJQUMxQixJQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxDQUFDVixNQUFNLENBQUNDLGNBQWMsQ0FBQ1EsTUFBTSxFQUFFRSxJQUFJLEVBQUU7UUFDcERDLFVBQVUsRUFBRSxJQUFJO1FBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtJQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNOLE9BQU8sRUFBRTtJQUNiRyxnQkFBZ0IsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDekIsT0FBT0EsZ0JBQWdCO0lBQzNCLENBQUM7SUFDREMsY0FBYyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUN2QixPQUFPQSxjQUFjO0lBQ3pCLENBQUM7SUFDREMsZ0JBQWdCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO1FBQ3pCLE9BQU9BLGdCQUFnQjtJQUMzQjtBQUNKLENBQUMsQ0FBQztBQUNGLE1BQU1PLGtCQUFrQixHQUFHQyxtQkFBTyxDQUFDLDZHQUFzQixDQUFDO0FBQzFEO0FBQ0E7QUFDQSxNQUFNQyxTQUFTLEdBQUc7SUFDZCxDQUFDRixrQkFBa0IsQ0FBQ0csc0JBQXNCLEdBQUc7Y0FBV0MsUUFBQUEsRUFBVSxFQUFFLENBQWQ7UUFDbEQsT0FBT0EsUUFBUTtJQUNuQixDQUFDO0lBQ0QsQ0FBQ0osa0JBQWtCLENBQUNLLHNCQUFzQixHQUFHO2NBQVdELFFBQUFBLEVBQVUsRUFBRSxDQUFkO1FBQ2xELE9BQU9BLFFBQVE7SUFDbkIsQ0FBQztJQUNELENBQUNKLGtCQUFrQixDQUFDTSxvQkFBb0IsR0FBRztjQUFXRixRQUFBQSxFQUFVLEVBQUUsQ0FBZDtRQUNoRCxPQUFPQSxRQUFRO0lBQ25CO0FBQ0osQ0FBQztBQUNELE1BQU1iLGdCQUFnQixHQUFHO0FBQ3pCO0FBQ0FXLFNBQVMsQ0FBQ0Ysa0JBQWtCLENBQUNHLHNCQUFzQixDQUFDSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsTUFBTWQsZ0JBQWdCLEdBQUc7QUFDekI7QUFDQVMsU0FBUyxDQUFDRixrQkFBa0IsQ0FBQ0ssc0JBQXNCLENBQUNFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3RCxNQUFNZixjQUFjLEdBQUc7QUFDdkI7QUFDQVUsU0FBUyxDQUFDRixrQkFBa0IsQ0FBQ00sb0JBQW9CLENBQUNDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9tZXRhZGF0YS9tZXRhZGF0YS1ib3VuZGFyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1ldGFkYXRhQm91bmRhcnk6IG51bGwsXG4gICAgT3V0bGV0Qm91bmRhcnk6IG51bGwsXG4gICAgVmlld3BvcnRCb3VuZGFyeTogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBNZXRhZGF0YUJvdW5kYXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1ldGFkYXRhQm91bmRhcnk7XG4gICAgfSxcbiAgICBPdXRsZXRCb3VuZGFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPdXRsZXRCb3VuZGFyeTtcbiAgICB9LFxuICAgIFZpZXdwb3J0Qm91bmRhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gVmlld3BvcnRCb3VuZGFyeTtcbiAgICB9XG59KTtcbmNvbnN0IF9tZXRhZGF0YWNvbnN0YW50cyA9IHJlcXVpcmUoXCIuL21ldGFkYXRhLWNvbnN0YW50c1wiKTtcbi8vIFdlIHVzZSBhIG5hbWVzcGFjZSBvYmplY3QgdG8gYWxsb3cgdXMgdG8gcmVjb3ZlciB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbi8vIGF0IHJ1bnRpbWUgZXZlbiB3aGVuIHByb2R1Y3Rpb24gYnVuZGxpbmcvbWluaWZpY2F0aW9uIGlzIHVzZWQuXG5jb25zdCBOYW1lU3BhY2UgPSB7XG4gICAgW19tZXRhZGF0YWNvbnN0YW50cy5NRVRBREFUQV9CT1VOREFSWV9OQU1FXTogZnVuY3Rpb24oeyBjaGlsZHJlbiB9KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9LFxuICAgIFtfbWV0YWRhdGFjb25zdGFudHMuVklFV1BPUlRfQk9VTkRBUllfTkFNRV06IGZ1bmN0aW9uKHsgY2hpbGRyZW4gfSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfSxcbiAgICBbX21ldGFkYXRhY29uc3RhbnRzLk9VVExFVF9CT1VOREFSWV9OQU1FXTogZnVuY3Rpb24oeyBjaGlsZHJlbiB9KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG59O1xuY29uc3QgTWV0YWRhdGFCb3VuZGFyeSA9IC8vIFdlIHVzZSBzbGljZSgwKSB0byB0cmljayB0aGUgYnVuZGxlciBpbnRvIG5vdCBpbmxpbmluZy9taW5pZnlpbmcgdGhlIGZ1bmN0aW9uXG4vLyBzbyBpdCByZXRhaW5zIHRoZSBuYW1lIGluZmVycmVkIGZyb20gdGhlIG5hbWVzcGFjZSBvYmplY3Rcbk5hbWVTcGFjZVtfbWV0YWRhdGFjb25zdGFudHMuTUVUQURBVEFfQk9VTkRBUllfTkFNRS5zbGljZSgwKV07XG5jb25zdCBWaWV3cG9ydEJvdW5kYXJ5ID0gLy8gV2UgdXNlIHNsaWNlKDApIHRvIHRyaWNrIHRoZSBidW5kbGVyIGludG8gbm90IGlubGluaW5nL21pbmlmeWluZyB0aGUgZnVuY3Rpb25cbi8vIHNvIGl0IHJldGFpbnMgdGhlIG5hbWUgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZXNwYWNlIG9iamVjdFxuTmFtZVNwYWNlW19tZXRhZGF0YWNvbnN0YW50cy5WSUVXUE9SVF9CT1VOREFSWV9OQU1FLnNsaWNlKDApXTtcbmNvbnN0IE91dGxldEJvdW5kYXJ5ID0gLy8gV2UgdXNlIHNsaWNlKDApIHRvIHRyaWNrIHRoZSBidW5kbGVyIGludG8gbm90IGlubGluaW5nL21pbmlmeWluZyB0aGUgZnVuY3Rpb25cbi8vIHNvIGl0IHJldGFpbnMgdGhlIG5hbWUgaW5mZXJyZWQgZnJvbSB0aGUgbmFtZXNwYWNlIG9iamVjdFxuTmFtZVNwYWNlW19tZXRhZGF0YWNvbnN0YW50cy5PVVRMRVRfQk9VTkRBUllfTkFNRS5zbGljZSgwKV07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLWJvdW5kYXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIk1ldGFkYXRhQm91bmRhcnkiLCJPdXRsZXRCb3VuZGFyeSIsIlZpZXdwb3J0Qm91bmRhcnkiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfbWV0YWRhdGFjb25zdGFudHMiLCJyZXF1aXJlIiwiTmFtZVNwYWNlIiwiTUVUQURBVEFfQk9VTkRBUllfTkFNRSIsImNoaWxkcmVuIiwiVklFV1BPUlRfQk9VTkRBUllfTkFNRSIsIk9VVExFVF9CT1VOREFSWV9OQU1FIiwic2xpY2UiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/metadata/metadata-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/lib/scheduler.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  atLeastOneTask: function () {\n    return atLeastOneTask;\n  },\n  scheduleImmediate: function () {\n    return scheduleImmediate;\n  },\n  scheduleOnNextTick: function () {\n    return scheduleOnNextTick;\n  },\n  waitAtLeastOneReactRenderTask: function () {\n    return waitAtLeastOneReactRenderTask;\n  }\n});\nconst scheduleOnNextTick = cb => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (false) {} else {\n      process.nextTick(cb);\n    }\n  });\n};\nconst scheduleImmediate = cb => {\n  if (false) {} else {\n    setImmediate(cb);\n  }\n};\nfunction atLeastOneTask() {\n  return new Promise(resolve => scheduleImmediate(resolve));\n}\nfunction waitAtLeastOneReactRenderTask() {\n  if (false) {} else {\n    return new Promise(r => setImmediate(r));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbGliL3NjaGVkdWxlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQUtMLENBQUM7QUFDRixTQUFTSyxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDWCxNQUFNLENBQUNDLGNBQWMsQ0FBQ1MsTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNQLE9BQU8sRUFBRTtFQUNiRyxjQUFjLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ3ZCLE9BQU9BLGNBQWM7RUFDekIsQ0FBQztFQUNEQyxpQkFBaUIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDMUIsT0FBT0EsaUJBQWlCO0VBQzVCLENBQUM7RUFDREMsa0JBQWtCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzNCLE9BQU9BLGtCQUFrQjtFQUM3QixDQUFDO0VBQ0RDLDZCQUE2QixFQUFFLFNBQUFBLENBQUEsRUFBVztJQUN0QyxPQUFPQSw2QkFBNkI7RUFDeEM7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNRCxrQkFBa0IsR0FBSVEsRUFBRSxJQUFHO0VBQzdCO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FBQyxNQUFJO0lBQ3ZCLElBQUlDLEtBQW1DLEVBQUUsRUFFeEMsTUFBTTtNQUNIQSxPQUFPLENBQUNJLFFBQVEsQ0FBQ1IsRUFBRSxDQUFDO0lBQ3hCO0VBQ0osQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUNELE1BQU1ULGlCQUFpQixHQUFJUyxFQUFFLElBQUc7RUFDNUIsSUFBSUksS0FBbUMsRUFBRSxFQUV4QyxNQUFNO0lBQ0hLLFlBQVksQ0FBQ1QsRUFBRSxDQUFDO0VBQ3BCO0FBQ0osQ0FBQztBQUNELFNBQVNWLGNBQWNBLENBQUEsRUFBRztFQUN0QixPQUFPLElBQUlXLE9BQU8sQ0FBRUMsT0FBTyxJQUFHWCxpQkFBaUIsQ0FBQ1csT0FBTyxDQUFDLENBQUM7QUFDN0Q7QUFDQSxTQUFTVCw2QkFBNkJBLENBQUEsRUFBRztFQUNyQyxJQUFJVyxLQUFtQyxFQUFFLEVBRXhDLE1BQU07SUFDSCxPQUFPLElBQUlILE9BQU8sQ0FBRVMsQ0FBQyxJQUFHRCxZQUFZLENBQUNDLENBQUMsQ0FBQyxDQUFDO0VBQzVDO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9saWIvc2NoZWR1bGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXRMZWFzdE9uZVRhc2s6IG51bGwsXG4gICAgc2NoZWR1bGVJbW1lZGlhdGU6IG51bGwsXG4gICAgc2NoZWR1bGVPbk5leHRUaWNrOiBudWxsLFxuICAgIHdhaXRBdExlYXN0T25lUmVhY3RSZW5kZXJUYXNrOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGF0TGVhc3RPbmVUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF0TGVhc3RPbmVUYXNrO1xuICAgIH0sXG4gICAgc2NoZWR1bGVJbW1lZGlhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVJbW1lZGlhdGU7XG4gICAgfSxcbiAgICBzY2hlZHVsZU9uTmV4dFRpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVPbk5leHRUaWNrO1xuICAgIH0sXG4gICAgd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2s7XG4gICAgfVxufSk7XG5jb25zdCBzY2hlZHVsZU9uTmV4dFRpY2sgPSAoY2IpPT57XG4gICAgLy8gV2UgdXNlIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKSBoZXJlIHNvIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyBzY2hlZHVsZWQgYXRcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBwcm9taXNlIGpvYiBxdWV1ZSwgd2UgdGhlbiBhZGQgaXQgdG8gdGhlIG5leHQgcHJvY2VzcyB0aWNrXG4gICAgLy8gdG8gZW5zdXJlIGl0J3MgZXZhbHVhdGVkIGFmdGVyd2FyZHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIHdhcyBpbnNwaXJlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIERhdGFMb2FkZXIgaW50ZXJmYWNlOiBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9kYXRhbG9hZGVyL2Jsb2IvZDMzNmJkMTUyODI2NjRlMGJlNGI0YTY1N2NiNzk2ZjA5YmFmYmM2Yi9zcmMvaW5kZXguanMjTDIxMy1MMjU1XG4gICAgLy9cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHNjaGVkdWxlSW1tZWRpYXRlID0gKGNiKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUUgPT09ICdlZGdlJykge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbW1lZGlhdGUoY2IpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBhdExlYXN0T25lVGFzaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT5zY2hlZHVsZUltbWVkaWF0ZShyZXNvbHZlKSk7XG59XG5mdW5jdGlvbiB3YWl0QXRMZWFzdE9uZVJlYWN0UmVuZGVyVGFzaygpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnZWRnZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKT0+c2V0VGltZW91dChyLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKT0+c2V0SW1tZWRpYXRlKHIpKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJhdExlYXN0T25lVGFzayIsInNjaGVkdWxlSW1tZWRpYXRlIiwic2NoZWR1bGVPbk5leHRUaWNrIiwid2FpdEF0TGVhc3RPbmVSZWFjdFJlbmRlclRhc2siLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJjYiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1JVTlRJTUUiLCJzZXRUaW1lb3V0IiwibmV4dFRpY2siLCJzZXRJbW1lZGlhdGUiLCJyIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage-instance.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/server/app-render/after-task-async-storage-instance.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"afterTaskAsyncStorageInstance\", ({\n  enumerable: true,\n  get: function () {\n    return afterTaskAsyncStorageInstance;\n  }\n}));\nconst _asynclocalstorage = __webpack_require__(/*! ./async-local-storage */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/async-local-storage.js\");\nconst afterTaskAsyncStorageInstance = (0, _asynclocalstorage.createAsyncLocalStorage)();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLWluc3RhbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxpRUFBZ0U7RUFDNURJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0MsNkJBQTZCO0VBQ3hDO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsa0JBQWtCLEdBQUdDLG1CQUFPLENBQUMsb0hBQXVCLENBQUM7QUFDM0QsTUFBTUYsNkJBQTZCLEdBQUcsQ0FBQyxDQUFDLEVBQUVDLGtCQUFrQixDQUFDRSx1QkFBdUIsRUFBRSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLWluc3RhbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlSW5zdGFuY2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyVGFza0FzeW5jU3RvcmFnZUluc3RhbmNlO1xuICAgIH1cbn0pO1xuY29uc3QgX2FzeW5jbG9jYWxzdG9yYWdlID0gcmVxdWlyZShcIi4vYXN5bmMtbG9jYWwtc3RvcmFnZVwiKTtcbmNvbnN0IGFmdGVyVGFza0FzeW5jU3RvcmFnZUluc3RhbmNlID0gKDAsIF9hc3luY2xvY2Fsc3RvcmFnZS5jcmVhdGVBc3luY0xvY2FsU3RvcmFnZSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLWluc3RhbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJhZnRlclRhc2tBc3luY1N0b3JhZ2VJbnN0YW5jZSIsIl9hc3luY2xvY2Fsc3RvcmFnZSIsInJlcXVpcmUiLCJjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage-instance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage.external.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/server/app-render/after-task-async-storage.external.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"afterTaskAsyncStorage\", ({\n  enumerable: true,\n  get: function () {\n    return _aftertaskasyncstorageinstance.afterTaskAsyncStorageInstance;\n  }\n}));\nconst _aftertaskasyncstorageinstance = __webpack_require__(/*! ./after-task-async-storage-instance */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage-instance.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLmV4dGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCx5REFBd0Q7RUFDcERJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0MsOEJBQThCLENBQUNDLDZCQUE2QjtFQUN2RTtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1ELDhCQUE4QixHQUFHRSxtQkFBTyxDQUFDLGdKQUFxQyxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvYWZ0ZXItdGFzay1hc3luYy1zdG9yYWdlLmV4dGVybmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWZ0ZXJ0YXNrYXN5bmNzdG9yYWdlaW5zdGFuY2UuYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlSW5zdGFuY2U7XG4gICAgfVxufSk7XG5jb25zdCBfYWZ0ZXJ0YXNrYXN5bmNzdG9yYWdlaW5zdGFuY2UgPSByZXF1aXJlKFwiLi9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UtaW5zdGFuY2VcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFmdGVyLXRhc2stYXN5bmMtc3RvcmFnZS5leHRlcm5hbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2FmdGVydGFza2FzeW5jc3RvcmFnZWluc3RhbmNlIiwiYWZ0ZXJUYXNrQXN5bmNTdG9yYWdlSW5zdGFuY2UiLCJyZXF1aXJlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage.external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/app-render/async-local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/server/app-render/async-local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  bindSnapshot: function () {\n    return bindSnapshot;\n  },\n  createAsyncLocalStorage: function () {\n    return createAsyncLocalStorage;\n  },\n  createSnapshot: function () {\n    return createSnapshot;\n  }\n});\nconst sharedAsyncLocalStorageNotAvailableError = new Error('Invariant: AsyncLocalStorage accessed in runtime where it is not available');\nclass FakeAsyncLocalStorage {\n  disable() {\n    throw sharedAsyncLocalStorageNotAvailableError;\n  }\n  getStore() {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined;\n  }\n  run() {\n    throw sharedAsyncLocalStorageNotAvailableError;\n  }\n  exit() {\n    throw sharedAsyncLocalStorageNotAvailableError;\n  }\n  enterWith() {\n    throw sharedAsyncLocalStorageNotAvailableError;\n  }\n  static bind(fn) {\n    return fn;\n  }\n}\nconst maybeGlobalAsyncLocalStorage = typeof globalThis !== 'undefined' && globalThis.AsyncLocalStorage;\nfunction createAsyncLocalStorage() {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage();\n  }\n  return new FakeAsyncLocalStorage();\n}\nfunction bindSnapshot(fn) {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn);\n  }\n  return FakeAsyncLocalStorage.bind(fn);\n}\nfunction createSnapshot() {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot();\n  }\n  return function (fn, ...args) {\n    return fn(...args);\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvYXN5bmMtbG9jYWwtc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRixDQUFDLEtBQUtDLENBSUwsQ0FBQztBQUNGLFNBQVNJLE9BQU9BLENBQUNDLE1BQU0sRUFBRUMsR0FBRyxFQUFFO0VBQzFCLEtBQUksSUFBSUMsSUFBSSxJQUFJRCxHQUFHLEVBQUNWLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUSxNQUFNLEVBQUVFLElBQUksRUFBRTtJQUNwREMsVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRUgsR0FBRyxDQUFDQyxJQUFJO0VBQ2pCLENBQUMsQ0FBQztBQUNOO0FBQ0FILE9BQU8sQ0FBQ04sT0FBTyxFQUFFO0VBQ2JHLFlBQVksRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDckIsT0FBT0EsWUFBWTtFQUN2QixDQUFDO0VBQ0RDLHVCQUF1QixFQUFFLFNBQUFBLENBQUEsRUFBVztJQUNoQyxPQUFPQSx1QkFBdUI7RUFDbEMsQ0FBQztFQUNEQyxjQUFjLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ3ZCLE9BQU9BLGNBQWM7RUFDekI7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyx3Q0FBd0MsR0FBRyxJQUFJQyxLQUFLLENBQUMsNEVBQTRFLENBQUM7QUFDeEksTUFBTUMscUJBQXFCLENBQUM7RUFDeEJDLE9BQU9BLENBQUEsRUFBRztJQUNOLE1BQU1ILHdDQUF3QztFQUNsRDtFQUNBSSxRQUFRQSxDQUFBLEVBQUc7SUFDUDtJQUNBLE9BQU9DLFNBQVM7RUFDcEI7RUFDQUMsR0FBR0EsQ0FBQSxFQUFHO0lBQ0YsTUFBTU4sd0NBQXdDO0VBQ2xEO0VBQ0FPLElBQUlBLENBQUEsRUFBRztJQUNILE1BQU1QLHdDQUF3QztFQUNsRDtFQUNBUSxTQUFTQSxDQUFBLEVBQUc7SUFDUixNQUFNUix3Q0FBd0M7RUFDbEQ7RUFDQSxPQUFPUyxJQUFJQSxDQUFDQyxFQUFFLEVBQUU7SUFDWixPQUFPQSxFQUFFO0VBQ2I7QUFDSjtBQUNBLE1BQU1DLDRCQUE0QixHQUFHLE9BQU9DLFVBQVUsS0FBSyxXQUFXLElBQUlBLFVBQVUsQ0FBQ0MsaUJBQWlCO0FBQ3RHLFNBQVNyQix1QkFBdUJBLENBQUEsRUFBRztFQUMvQixJQUFJbUIsNEJBQTRCLEVBQUU7SUFDOUIsT0FBTyxJQUFJQSw0QkFBNEIsQ0FBQyxDQUFDO0VBQzdDO0VBQ0EsT0FBTyxJQUFJVCxxQkFBcUIsQ0FBQyxDQUFDO0FBQ3RDO0FBQ0EsU0FBU1gsWUFBWUEsQ0FBQ21CLEVBQUUsRUFBRTtFQUN0QixJQUFJQyw0QkFBNEIsRUFBRTtJQUM5QixPQUFPQSw0QkFBNEIsQ0FBQ0YsSUFBSSxDQUFDQyxFQUFFLENBQUM7RUFDaEQ7RUFDQSxPQUFPUixxQkFBcUIsQ0FBQ08sSUFBSSxDQUFDQyxFQUFFLENBQUM7QUFDekM7QUFDQSxTQUFTakIsY0FBY0EsQ0FBQSxFQUFHO0VBQ3RCLElBQUlrQiw0QkFBNEIsRUFBRTtJQUM5QixPQUFPQSw0QkFBNEIsQ0FBQ0csUUFBUSxDQUFDLENBQUM7RUFDbEQ7RUFDQSxPQUFPLFVBQVNKLEVBQUUsRUFBRSxHQUFHSyxJQUFJLEVBQUU7SUFDekIsT0FBT0wsRUFBRSxDQUFDLEdBQUdLLElBQUksQ0FBQztFQUN0QixDQUFDO0FBQ0wiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvYXBwLXJlbmRlci9hc3luYy1sb2NhbC1zdG9yYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmluZFNuYXBzaG90OiBudWxsLFxuICAgIGNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlOiBudWxsLFxuICAgIGNyZWF0ZVNuYXBzaG90OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGJpbmRTbmFwc2hvdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiaW5kU25hcHNob3Q7XG4gICAgfSxcbiAgICBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9LFxuICAgIGNyZWF0ZVNuYXBzaG90OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBzaG90O1xuICAgIH1cbn0pO1xuY29uc3Qgc2hhcmVkQXN5bmNMb2NhbFN0b3JhZ2VOb3RBdmFpbGFibGVFcnJvciA9IG5ldyBFcnJvcignSW52YXJpYW50OiBBc3luY0xvY2FsU3RvcmFnZSBhY2Nlc3NlZCBpbiBydW50aW1lIHdoZXJlIGl0IGlzIG5vdCBhdmFpbGFibGUnKTtcbmNsYXNzIEZha2VBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhyb3cgc2hhcmVkQXN5bmNMb2NhbFN0b3JhZ2VOb3RBdmFpbGFibGVFcnJvcjtcbiAgICB9XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIC8vIFRoaXMgZmFrZSBpbXBsZW1lbnRhdGlvbiBvZiBBc3luY0xvY2FsU3RvcmFnZSBhbHdheXMgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICB0aHJvdyBzaGFyZWRBc3luY0xvY2FsU3RvcmFnZU5vdEF2YWlsYWJsZUVycm9yO1xuICAgIH1cbiAgICBleGl0KCkge1xuICAgICAgICB0aHJvdyBzaGFyZWRBc3luY0xvY2FsU3RvcmFnZU5vdEF2YWlsYWJsZUVycm9yO1xuICAgIH1cbiAgICBlbnRlcldpdGgoKSB7XG4gICAgICAgIHRocm93IHNoYXJlZEFzeW5jTG9jYWxTdG9yYWdlTm90QXZhaWxhYmxlRXJyb3I7XG4gICAgfVxuICAgIHN0YXRpYyBiaW5kKGZuKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG59XG5jb25zdCBtYXliZUdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuQXN5bmNMb2NhbFN0b3JhZ2U7XG5mdW5jdGlvbiBjcmVhdGVBc3luY0xvY2FsU3RvcmFnZSgpIHtcbiAgICBpZiAobWF5YmVHbG9iYWxBc3luY0xvY2FsU3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gbmV3IG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGYWtlQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbn1cbmZ1bmN0aW9uIGJpbmRTbmFwc2hvdChmbikge1xuICAgIGlmIChtYXliZUdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXliZUdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlLmJpbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gRmFrZUFzeW5jTG9jYWxTdG9yYWdlLmJpbmQoZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlU25hcHNob3QoKSB7XG4gICAgaWYgKG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlR2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2Uuc25hcHNob3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZuLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBmbiguLi5hcmdzKTtcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1sb2NhbC1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImJpbmRTbmFwc2hvdCIsImNyZWF0ZUFzeW5jTG9jYWxTdG9yYWdlIiwiY3JlYXRlU25hcHNob3QiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJzaGFyZWRBc3luY0xvY2FsU3RvcmFnZU5vdEF2YWlsYWJsZUVycm9yIiwiRXJyb3IiLCJGYWtlQXN5bmNMb2NhbFN0b3JhZ2UiLCJkaXNhYmxlIiwiZ2V0U3RvcmUiLCJ1bmRlZmluZWQiLCJydW4iLCJleGl0IiwiZW50ZXJXaXRoIiwiYmluZCIsImZuIiwibWF5YmVHbG9iYWxBc3luY0xvY2FsU3RvcmFnZSIsImdsb2JhbFRoaXMiLCJBc3luY0xvY2FsU3RvcmFnZSIsInNuYXBzaG90IiwiYXJncyJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/app-render/async-local-storage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createDedupedByCallsiteServerErrorLoggerDev\", ({\n  enumerable: true,\n  get: function () {\n    return createDedupedByCallsiteServerErrorLoggerDev;\n  }\n}));\nconst _react = /*#__PURE__*/_interop_require_wildcard(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {\n    __proto__: null\n  };\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst errorRef = {\n  current: null\n};\n// React.cache is currently only available in canary/experimental React channels.\nconst cache = typeof _react.cache === 'function' ? _react.cache : fn => fn;\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn =  false ? 0 : console.warn;\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\nkey => {\n  try {\n    logErrorOrWarn(errorRef.current);\n  } finally {\n    errorRef.current = null;\n  }\n});\nfunction createDedupedByCallsiteServerErrorLoggerDev(getMessage) {\n  return function logDedupedError(...args) {\n    const message = getMessage(...args);\n    if (true) {\n      var _stack;\n      const callStackFrames = (_stack = new Error().stack) == null ? void 0 : _stack.split('\\n');\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message);\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4];\n        errorRef.current = message;\n        flushCurrentErrorIfNew(key);\n      }\n    } else {}\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILCtFQUE4RTtFQUMxRUksVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDWixPQUFPQywyQ0FBMkM7RUFDdEQ7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxNQUFNLEdBQUcsYUFBY0MseUJBQXlCLENBQUNDLG1CQUFPLENBQUMsbUZBQU8sQ0FBQyxDQUFDO0FBQ3hFLFNBQVNDLHdCQUF3QkEsQ0FBQ0MsV0FBVyxFQUFFO0VBQzNDLElBQUksT0FBT0MsT0FBTyxLQUFLLFVBQVUsRUFBRSxPQUFPLElBQUk7RUFDOUMsSUFBSUMsaUJBQWlCLEdBQUcsSUFBSUQsT0FBTyxDQUFDLENBQUM7RUFDckMsSUFBSUUsZ0JBQWdCLEdBQUcsSUFBSUYsT0FBTyxDQUFDLENBQUM7RUFDcEMsT0FBTyxDQUFDRix3QkFBd0IsR0FBRyxTQUFBQSxDQUFTQyxXQUFXLEVBQUU7SUFDckQsT0FBT0EsV0FBVyxHQUFHRyxnQkFBZ0IsR0FBR0QsaUJBQWlCO0VBQzdELENBQUMsRUFBRUYsV0FBVyxDQUFDO0FBQ25CO0FBQ0EsU0FBU0gseUJBQXlCQSxDQUFDTyxHQUFHLEVBQUVKLFdBQVcsRUFBRTtFQUNqRCxJQUFJLENBQUNBLFdBQVcsSUFBSUksR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsRUFBRTtJQUN2QyxPQUFPRCxHQUFHO0VBQ2Q7RUFDQSxJQUFJQSxHQUFHLEtBQUssSUFBSSxJQUFJLE9BQU9BLEdBQUcsS0FBSyxRQUFRLElBQUksT0FBT0EsR0FBRyxLQUFLLFVBQVUsRUFBRTtJQUN0RSxPQUFPO01BQ0hFLE9BQU8sRUFBRUY7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c0JBQXNCLENBQUNoQixHQUFHLENBQUM7TUFDL0I7SUFDSixDQUFDLE1BQU0sRUFFTjtFQUNMLENBQUM7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldlwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldjtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICAgIHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24obm9kZUludGVyb3ApIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wO1xuICAgIH0pKG5vZGVJbnRlcm9wKTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkge1xuICAgIGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApO1xuICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gICAgfVxuICAgIHZhciBuZXdPYmogPSB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbFxuICAgIH07XG4gICAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgIGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gICAgfVxuICAgIHJldHVybiBuZXdPYmo7XG59XG5jb25zdCBlcnJvclJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsXG59O1xuLy8gUmVhY3QuY2FjaGUgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIGNhbmFyeS9leHBlcmltZW50YWwgUmVhY3QgY2hhbm5lbHMuXG5jb25zdCBjYWNoZSA9IHR5cGVvZiBfcmVhY3QuY2FjaGUgPT09ICdmdW5jdGlvbicgPyBfcmVhY3QuY2FjaGUgOiAoZm4pPT5mbjtcbi8vIFdoZW4gRHluYW1pYyBJTyBpcyBlbmFibGVkLCB3ZSByZWNvcmQgdGhlc2UgYXMgZXJyb3JzIHNvIHRoYXQgdGhleVxuLy8gYXJlIGNhcHR1cmVkIGJ5IHRoZSBkZXYgb3ZlcmxheSBhcyBpdCdzIG1vcmUgY3JpdGljYWwgdG8gZml4IHRoZXNlXG4vLyB3aGVuIGVuYWJsZWQuXG5jb25zdCBsb2dFcnJvck9yV2FybiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9EWU5BTUlDX0lPID8gY29uc29sZS5lcnJvciA6IGNvbnNvbGUud2Fybjtcbi8vIFdlIGRvbid0IHdhbnQgdG8gZGVkdXBlIGFjcm9zcyByZXF1ZXN0cy5cbi8vIFRoZSBkZXZlbG9wZXIgbWlnaHQndmUganVzdCBhdHRlbXB0ZWQgdG8gZml4IHRoZSB3YXJuaW5nIHNvIHdlIHNob3VsZCB3YXJuIGFnYWluIGlmIGl0IHN0aWxsIGhhcHBlbnMuXG5jb25zdCBmbHVzaEN1cnJlbnRFcnJvcklmTmV3ID0gY2FjaGUoLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAtLSBjYWNoZSBrZXlcbihrZXkpPT57XG4gICAgdHJ5IHtcbiAgICAgICAgbG9nRXJyb3JPcldhcm4oZXJyb3JSZWYuY3VycmVudCk7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICBlcnJvclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoZ2V0TWVzc2FnZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBsb2dEZWR1cGVkRXJyb3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZSguLi5hcmdzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBfc3RhY2s7XG4gICAgICAgICAgICBjb25zdCBjYWxsU3RhY2tGcmFtZXMgPSAoX3N0YWNrID0gbmV3IEVycm9yKCkuc3RhY2spID09IG51bGwgPyB2b2lkIDAgOiBfc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGNhbGxTdGFja0ZyYW1lcyA9PT0gdW5kZWZpbmVkIHx8IGNhbGxTdGFja0ZyYW1lcy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3JPcldhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVycm9yOlxuICAgICAgICAgICAgICAgIC8vICAgbG9nRGVkdXBlZEVycm9yXG4gICAgICAgICAgICAgICAgLy8gICBhc3luY0FwaUJlaW5nQWNjZXNzZWRTeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgLy8gICA8dXNlcmxhbmQgY2FsbHNpdGU+XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3MgaWYgc291cmNlbWFwcyB3aXRoIGlnbm9yZSBsaXN0cyBhcmUgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjYWxsU3RhY2tGcmFtZXNbNF07XG4gICAgICAgICAgICAgICAgZXJyb3JSZWYuY3VycmVudCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZmx1c2hDdXJyZW50RXJyb3JJZk5ldyhrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nRXJyb3JPcldhcm4obWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2IiwiX3JlYWN0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlIiwiaGFzIiwibmV3T2JqIiwiX19wcm90b19fIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsImVycm9yUmVmIiwiY3VycmVudCIsImZuIiwibG9nRXJyb3JPcldhcm4iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0RZTkFNSUNfSU8iLCJjb25zb2xlIiwiZXJyb3IiLCJ3YXJuIiwiZmx1c2hDdXJyZW50RXJyb3JJZk5ldyIsImdldE1lc3NhZ2UiLCJsb2dEZWR1cGVkRXJyb3IiLCJhcmdzIiwibWVzc2FnZSIsIk5PREVfRU5WIiwiX3N0YWNrIiwiY2FsbFN0YWNrRnJhbWVzIiwiRXJyb3IiLCJzdGFjayIsInNwbGl0IiwidW5kZWZpbmVkIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/server/request/params.browser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createRenderParamsFromClient\", ({\n  enumerable: true,\n  get: function () {\n    return createRenderParamsFromClient;\n  }\n}));\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nfunction createRenderParamsFromClient(underlyingParams) {\n  if (true) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams);\n  } else {}\n}\nconst CachedParams = new WeakMap();\nfunction makeUntrackedExoticParams(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const promise = Promise.resolve(underlyingParams);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams);\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n        // We are accessing a property that was proxied to the promise instance\n        proxiedProperties.has(prop)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n    },\n    ownKeys(target) {\n      warnForEnumeration(unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedParams.set(underlyingParams, proxiedPromise);\n  return proxiedPromise;\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : function warnForSyncAccess(expression) {\n  if (false) {}\n  console.error(`A param property was accessed directly with ${expression}. \\`params\\` is now a Promise and should be unwrapped with \\`React.use()\\` before accessing properties of the underlying params object. In this version of Next.js direct access to param properties is still supported to facilitate migration but in a future version you will be required to unwrap \\`params\\` with \\`React.use()\\`.`);\n};\nconst warnForEnumeration =  false ? 0 : function warnForEnumeration(missingProperties) {\n  if (false) {}\n  if (missingProperties.length) {\n    const describedMissingProperties = describeListOfPropertyNames(missingProperties);\n    console.error(`params are being enumerated incompletely missing these properties: ${describedMissingProperties}. ` + `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n  } else {\n    console.error(`params are being enumerated. ` + `\\`params\\` should be unwrapped with \\`React.use()\\` before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n  }\n};\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGdFQUErRDtFQUMzREksVUFBVSxFQUFFLElBQUk7RUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDWixPQUFPQyw0QkFBNEI7RUFDdkM7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsZUFBZSxHQUFHRCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLE1BQU1FLE1BQU0sR0FBR0YsbUJBQU8sQ0FBQyxxRkFBUyxDQUFDO0FBQ2pDLFNBQVNGLDRCQUE0QkEsQ0FBQ0ssZ0JBQWdCLEVBQUU7RUFDcEQsSUFBSUMsSUFBc0MsRUFBRTtJQUN4QyxPQUFPRyxpREFBaUQsQ0FBQ0osZ0JBQWdCLENBQUM7RUFDOUUsQ0FBQyxNQUFNLEVBRU47QUFDTDtBQUNBLE1BQU1NLFlBQVksR0FBRyxJQUFJQyxPQUFPLENBQUMsQ0FBQztBQUNsQyxTQUFTRix5QkFBeUJBLENBQUNMLGdCQUFnQixFQUFFO0VBQ2pELE1BQU1RLFlBQVksR0FBR0YsWUFBWSxDQUFDWixHQUFHLENBQUNNLGdCQUFnQixDQUFDO0VBQ3ZELElBQUlRLFlBQVksRUFBRTtJQUNkLE9BQU9BLFlBQVk7RUFDdkI7RUFDQSxNQUFNQyxPQUFPLEdBQUdDLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDWCxnQkFBZ0IsQ0FBQztFQUNqRE0sWUFBWSxDQUFDTSxHQUFHLENBQUNaLGdCQUFnQixFQUFFUyxPQUFPLENBQUM7RUFDM0NwQixNQUFNLENBQUN3QixJQUFJLENBQUNiLGdCQUFnQixDQUFDLENBQUNjLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQzFDLElBQUlo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QUMsQ0FBRSxJQUFHO1FBQy9ELE9BQU9LLFdBQVc7TUFDdEI7RUFDUjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH1cbn0pO1xuY29uc3QgX3JlZmxlY3QgPSByZXF1aXJlKFwiLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3RcIik7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQodW5kZXJseWluZ1BhcmFtcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICByZXR1cm4gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWRQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdQYXJhbXMpIHtcbiAgICBjb25zdCBjYWNoZWRQYXJhbXMgPSBDYWNoZWRQYXJhbXMuZ2V0KHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIGlmIChjYWNoZWRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBhcmFtcztcbiAgICB9XG4gICAgLy8gV2UgZG9uJ3QgdXNlIG1ha2VSZXNvbHZlZFJlYWN0UHJvbWlzZSBoZXJlIGJlY2F1c2UgcGFyYW1zXG4gICAgLy8gc3VwcG9ydHMgY29weWluZyB3aXRoIHNwcmVhZCBhbmQgd2UgZG9uJ3Qgd2FudCB0byB1bm5lY2Vzc2FyaWx5XG4gICAgLy8gaW5zdHJ1bWVudCB0aGUgcHJvbWlzZSB3aXRoIHNwcmVhZGFibGUgcHJvcGVydGllcyBvZiBSZWFjdFByb21pc2UuXG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzID0gW107XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICAgICAgZ2V0ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IHdhcyBwcm94aWVkIHRvIHRoZSBwcm9taXNlIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JFbnVtZXJhdGlvbih1bnByb3hpZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmNvbnN0IG5vb3AgPSAoKT0+e307XG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogZnVuY3Rpb24gd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbikge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihgQSBwYXJhbSBwcm9wZXJ0eSB3YXMgYWNjZXNzZWQgZGlyZWN0bHkgd2l0aCAke2V4cHJlc3Npb259LiBcXGBwYXJhbXNcXGAgaXMgbm93IGEgUHJvbWlzZSBhbmQgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSBhY2Nlc3NpbmcgcHJvcGVydGllcyBvZiB0aGUgdW5kZXJseWluZyBwYXJhbXMgb2JqZWN0LiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyBkaXJlY3QgYWNjZXNzIHRvIHBhcmFtIHByb3BlcnRpZXMgaXMgc3RpbGwgc3VwcG9ydGVkIHRvIGZhY2lsaXRhdGUgbWlncmF0aW9uIGJ1dCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHlvdSB3aWxsIGJlIHJlcXVpcmVkIHRvIHVud3JhcCBcXGBwYXJhbXNcXGAgd2l0aCBcXGBSZWFjdC51c2UoKVxcYC5gKTtcbn07XG5jb25zdCB3YXJuRm9yRW51bWVyYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTID8gbm9vcCA6IGZ1bmN0aW9uIHdhcm5Gb3JFbnVtZXJhdGlvbihtaXNzaW5nUHJvcGVydGllcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZXNjcmliZWRNaXNzaW5nUHJvcGVydGllcyA9IGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHBhcmFtcyBhcmUgYmVpbmcgZW51bWVyYXRlZCBpbmNvbXBsZXRlbHkgbWlzc2luZyB0aGVzZSBwcm9wZXJ0aWVzOiAke2Rlc2NyaWJlZE1pc3NpbmdQcm9wZXJ0aWVzfS4gYCArIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIHVud3JhcHBlZCB3aXRoIFxcYFJlYWN0LnVzZSgpXFxgIGJlZm9yZSB1c2luZyBpdHMgdmFsdWUuIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBwYXJhbXMgYXJlIGJlaW5nIGVudW1lcmF0ZWQuIGAgKyBgXFxgcGFyYW1zXFxgIHNob3VsZCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgdXNpbmcgaXRzIHZhbHVlLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKSB7XG4gICAgc3dpdGNoKHByb3BlcnRpZXMubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhyb3cgbmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW1zLmJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiLCJfcmVmbGVjdCIsInJlcXVpcmUiLCJfaW52YXJpYW50ZXJyb3IiLCJfdXRpbHMiLCJ1bmRlcmx5aW5nUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXMiLCJDYWNoZWRQYXJhbXMiLCJXZWFrTWFwIiwiY2FjaGVkUGFyYW1zIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0Iiwia2V5cyIsImZvckVhY2giLCJwcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsImhhcyIsInByb3hpZWRQcm9wZXJ0aWVzIiwiU2V0IiwidW5wcm94aWVkUHJvcGVydGllcyIsImFkZCIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJyZWNlaXZlciIsImV4cHJlc3Npb24iLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwid2FybkZvclN5bmNBY2Nlc3MiLCJSZWZsZWN0QWRhcHRlciIsImRlbGV0ZSIsIm93bktleXMiLCJ3YXJuRm9yRW51bWVyYXRpb24iLCJSZWZsZWN0Iiwibm9vcCIsIl9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MiLCJjb25zb2xlIiwiZXJyb3IiLCJtaXNzaW5nUHJvcGVydGllcyIsImxlbmd0aCIsImRlc2NyaWJlZE1pc3NpbmdQcm9wZXJ0aWVzIiwiZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsIkludmFyaWFudEVycm9yIiwiZGVzY3JpcHRpb24iLCJpIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/params.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/server/request/params.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createParamsFromClient: function () {\n    return createParamsFromClient;\n  },\n  createPrerenderParamsForClientSegment: function () {\n    return createPrerenderParamsForClientSegment;\n  },\n  createServerParamsForMetadata: function () {\n    return createServerParamsForMetadata;\n  },\n  createServerParamsForRoute: function () {\n    return createServerParamsForRoute;\n  },\n  createServerParamsForServerSegment: function () {\n    return createServerParamsForServerSegment;\n  }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createParamsFromClient(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nconst createServerParamsForMetadata = createServerParamsForServerSegment;\nfunction createServerParamsForRoute(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nfunction createServerParamsForServerSegment(underlyingParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderParams(underlyingParams, workStore);\n}\nfunction createPrerenderParamsForClientSegment(underlyingParams, workStore) {\n  const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    const fallbackParams = workStore.fallbackRouteParams;\n    if (fallbackParams) {\n      for (let key in underlyingParams) {\n        if (fallbackParams.has(key)) {\n          // This params object has one of more fallback params so we need to consider\n          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n          // we encode this as a promise that never resolves\n          return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n        }\n      }\n    }\n  }\n  // We're prerendering in a mode that does not abort. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve(underlyingParams);\n}\nfunction createPrerenderParams(underlyingParams, workStore, prerenderStore) {\n  const fallbackParams = workStore.fallbackRouteParams;\n  if (fallbackParams) {\n    let hasSomeFallbackParams = false;\n    for (const key in underlyingParams) {\n      if (fallbackParams.has(key)) {\n        hasSomeFallbackParams = true;\n        break;\n      }\n    }\n    if (hasSomeFallbackParams) {\n      // params need to be treated as dynamic because we have at least one fallback param\n      if (prerenderStore.type === 'prerender') {\n        // We are in a dynamicIO (PPR or otherwise) prerender\n        return makeAbortingExoticParams(underlyingParams, workStore.route, prerenderStore);\n      }\n      // remaining cases are prender-ppr and prerender-legacy\n      // We aren't in a dynamicIO prerender but we do have fallback params at this\n      // level so we need to make an erroring exotic params object which will postpone\n      // if you access the fallback params\n      return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n    }\n  }\n  // We don't have any fallback params so we have an entirely static safe params object\n  return makeUntrackedExoticParams(underlyingParams);\n}\nfunction createRenderParams(underlyingParams, workStore) {\n  if ( true && !workStore.isPrefetchRequest) {\n    return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, workStore);\n  } else {\n    return makeUntrackedExoticParams(underlyingParams);\n  }\n}\nconst CachedParams = new WeakMap();\nfunction makeAbortingExoticParams(underlyingParams, route, prerenderStore) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      Object.defineProperty(promise, prop, {\n        get() {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          const error = createParamsAccessError(route, expression);\n          (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true\n          });\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  });\n  return promise;\n}\nfunction makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  const augmentedUnderlying = {\n    ...underlyingParams\n  };\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(augmentedUnderlying);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      if (fallbackParams.has(prop)) {\n        Object.defineProperty(augmentedUnderlying, prop, {\n          get() {\n            const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n          },\n          enumerable: true\n        });\n        Object.defineProperty(promise, prop, {\n          get() {\n            const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n            // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n            // for params is only dynamic when we're generating a fallback shell\n            // and even when `dynamic = \"error\"` we still support generating dynamic\n            // fallback shells\n            // TODO remove this comment when dynamicIO is the default since there\n            // will be no `dynamic = \"error\"`\n            if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n          },\n          set(newValue) {\n            Object.defineProperty(promise, prop, {\n              value: newValue,\n              writable: true,\n              enumerable: true\n            });\n          },\n          enumerable: true,\n          configurable: true\n        });\n      } else {\n        ;\n        promise[prop] = underlyingParams[prop];\n      }\n    }\n  });\n  return promise;\n}\nfunction makeUntrackedExoticParams(underlyingParams) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingParams);\n  CachedParams.set(underlyingParams, promise);\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {\n  const cachedParams = CachedParams.get(underlyingParams);\n  if (cachedParams) {\n    return cachedParams;\n  }\n  // We don't use makeResolvedReactPromise here because params\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise(resolve => (0, _scheduler.scheduleImmediate)(() => resolve(underlyingParams)));\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  Object.keys(underlyingParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (\n        // We are accessing a property that was proxied to the promise instance\n        proxiedProperties.has(prop)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n    },\n    ownKeys(target) {\n      const expression = '`...params` or similar expression';\n      syncIODev(store.route, expression, unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedParams.set(underlyingParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore;\n    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n  }\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties);\n  } else {\n    warnForSyncAccess(route, expression);\n  }\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createParamsAccessError(route, expression) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGLENBQUMsS0FBS0MsQ0FNTCxDQUFDO0FBQ0YsU0FBU00sT0FBT0EsQ0FBQ0MsTUFBTSxFQUFFQyxHQUFHLEVBQUU7RUFDMUIsS0FBSSxJQUFJQyxJQUFJLElBQUlELEdBQUcsRUFBQ1osTUFBTSxDQUFDQyxjQUFjLENBQUNVLE1BQU0sRUFBRUUsSUFBSSxFQUFFO0lBQ3BEQyxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFSCxHQUFHLENBQUNDLElBQUk7RUFDakIsQ0FBQyxDQUFDO0FBQ047QUFDQUgsT0FBTyxDQUFDUixPQUFPLEVBQUU7RUFDYkcsc0JBQXNCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQy9CLE9BQU9BLHNCQUFzQjtFQUNqQyxDQUFDO0VBQ0RDLHFDQUFxQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM5QyxPQUFPQSxxQ0FBcUM7RUFDaEQsQ0FBQztFQUNEQyw2QkFBNkIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDdEMsT0FBT0EsNkJBQTZCO0VBQ3hDLENBQUM7RUFDREMsMEJBQTBCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ25DLE9BQU9BLDBCQUEwQjtFQUNyQyxDQUFDO0VBQ0RDLGtDQUFrQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUMzQyxPQUFPQSxrQ0FBa0M7RUFDN0M7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsaUJBQWlCLEdBQUdELG1CQUFPLENBQUMsNEhBQWlDLENBQUM7QUFDcEUsTUFBTUUsNkJBQTZCLEdBQUdGLG1CQUFPLENBQUMsK0lBQWdELENBQUM7QUFDL0YsTUFBTUcsZUFBZSxH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SSxnRUFBK0QsQ0FBQztBQUM1VztBQUNBLFNBQVNhLDJCQUEyQkEsQ0FBQ0MsVUFBVSxFQUFFO0VBQzdDLFFBQU9BLFVBQVUsQ0FBQ1YsTUFBTTtJQUNwQixLQUFLLENBQUM7TUFDRixNQUFNLElBQUl4RSxlQUFlLENBQUNtRixjQUFjLENBQUMscUZBQXFGLENBQUM7SUFDbkksS0FBSyxDQUFDO01BQ0YsT0FBUSxLQUFJRCxVQUFVLENBQUMsQ0FBQyxDQUFFLElBQUc7SUFDakMsS0FBSyxDQUFDO01BQ0YsT0FBUSxLQUFJQSxVQUFVLENBQUMsQ0FBQyxDQUFFLFlBQVdBLFVBQVUsQ0FBQyxDQUFDLENBQUUsSUFBRztJQUMxRDtNQUNJO1FBQ0ksSUFBSUUsV0FBVyxHQUFHLEVBQUU7UUFDcEIsS0FBSSxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdILFVBQVUsQ0FBQ1YsTUFBTSxHQUFHLENBQUMsRUFBRWEsQ0FBQyxFQUFFLEVBQUM7VUFDMUNELFdBQVcsSUFBSyxLQUFJRixVQUFVLENBQUNHLENBQUMsQ0FBRSxNQUFLO1FBQzNDO1FBQ0FELFdBQVcsSUFBSyxXQUFVRixVQUFVLENBQUNBLFVBQVUsQ0FBQ1YsTUFBTSxHQUFHLENBQUMsQ0FBRSxJQUFHO1FBQy9ELE9BQU9ZLFdBQVc7TUFDdEI7RUFDUjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogbnVsbCxcbiAgICBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50OiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclJvdXRlOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUHJlcmVuZGVyUGFyYW1zRm9yQ2xpZW50U2VnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE7XG4gICAgfSxcbiAgICBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTtcbiAgICB9LFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yU2VydmVyU2VnbWVudDtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWZsZWN0ID0gcmVxdWlyZShcIi4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0XCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmcgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlciA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyXCIpO1xuY29uc3QgX3NjaGVkdWxlciA9IHJlcXVpcmUoXCIuLi8uLi9saWIvc2NoZWR1bGVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlUGFyYW1zRnJvbUNsaWVudCh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpIHtcbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICBzd2l0Y2god29ya1VuaXRTdG9yZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpO1xufVxuY29uc3QgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgPSBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JTZXJ2ZXJTZWdtZW50O1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyUGFyYW1zRm9yUm91dGUodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclBhcmFtc0ZvckNsaWVudFNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIHVuZGVybHlpbmdQYXJhbXMpe1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtcyBvYmplY3QgaGFzIG9uZSBvZiBtb3JlIGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBuZWVkIHRvIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhd2FpdGluZyBvZiB0aGlzIHBhcmFtcyBvYmplY3QgXCJkeW5hbWljXCIuIFNpbmNlIHdlIGFyZSBpbiBkeW5hbWljSU8gbW9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBlbmNvZGUgdGhpcyBhcyBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnQuIFdlIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aG91dFxuICAgIC8vIGFueSB0cmFja2luZyBiZWNhdXNlIHdlJ3JlIGp1c3QgdHJhbnNwb3J0aW5nIGEgdmFsdWUgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IHdoZXJlIHRoZSB0cmFja2luZ1xuICAgIC8vIHdpbGwgYmUgYXBwbGllZC5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgIGlmIChmYWxsYmFja1BhcmFtcykge1xuICAgICAgICBsZXQgaGFzU29tZUZhbGxiYWNrUGFyYW1zID0gZmFsc2U7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcyl7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTb21lRmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtcyBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZHluYW1pYyBiZWNhdXNlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGZhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQWJvcnRpbmdFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLnJvdXRlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1haW5pbmcgY2FzZXMgYXJlIHByZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgaW4gYSBkeW5hbWljSU8gcHJlcmVuZGVyIGJ1dCB3ZSBkbyBoYXZlIGZhbGxiYWNrIHBhcmFtcyBhdCB0aGlzXG4gICAgICAgICAgICAvLyBsZXZlbCBzbyB3ZSBuZWVkIHRvIG1ha2UgYW4gZXJyb3JpbmcgZXhvdGljIHBhcmFtcyBvYmplY3Qgd2hpY2ggd2lsbCBwb3N0cG9uZVxuICAgICAgICAgICAgLy8gaWYgeW91IGFjY2VzcyB0aGUgZmFsbGJhY2sgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBoYXZlIGFueSBmYWxsYmFjayBwYXJhbXMgc28gd2UgaGF2ZSBhbiBlbnRpcmVseSBzdGF0aWMgc2FmZSBwYXJhbXMgb2JqZWN0XG4gICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWRQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWFrZUFib3J0aW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHJvdXRlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IGF1Z21lbnRlZFVuZGVybHlpbmcgPSB7XG4gICAgICAgIC4uLnVuZGVybHlpbmdQYXJhbXNcbiAgICB9O1xuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXVnbWVudGVkVW5kZXJseWluZyk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXVnbWVudGVkVW5kZXJseWluZywgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gbW9zdCBkeW5hbWljIEFQSXMgd2UgYWxzbyB0aHJvdyBpZiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaG93ZXZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhcmFtcyBpcyBvbmx5IGR5bmFtaWMgd2hlbiB3ZSdyZSBnZW5lcmF0aW5nIGEgZmFsbGJhY2sgc2hlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBldmVuIHdoZW4gYGR5bmFtaWMgPSBcImVycm9yXCJgIHdlIHN0aWxsIHN1cHBvcnQgZ2VuZXJhdGluZyBkeW5hbWljXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayBzaGVsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgY29tbWVudCB3aGVuIGR5bmFtaWNJTyBpcyB0aGUgZGVmYXVsdCBzaW5jZSB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBubyBgZHluYW1pYyA9IFwiZXJyb3JcImBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIG1vc3QgZHluYW1pYyBBUElzIHdlIGFsc28gdGhyb3cgaWYgYGR5bmFtaWMgPSBcImVycm9yXCJgIGhvd2V2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwYXJhbXMgaXMgb25seSBkeW5hbWljIHdoZW4gd2UncmUgZ2VuZXJhdGluZyBhIGZhbGxiYWNrIHNoZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZXZlbiB3aGVuIGBkeW5hbWljID0gXCJlcnJvclwiYCB3ZSBzdGlsbCBzdXBwb3J0IGdlbmVyYXRpbmcgZHluYW1pY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgc2hlbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGNvbW1lbnQgd2hlbiBkeW5hbWljSU8gaXMgdGhlIGRlZmF1bHQgc2luY2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgbm8gYGR5bmFtaWMgPSBcImVycm9yXCJgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0IChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT4oMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PnJlc29sdmUodW5kZXJseWluZ1BhcmFtcykpKTtcbiAgICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzID0gW107XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgd2FzIHByb3hpZWQgdG8gdGhlIHByb21pc2UgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyAodGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5wYXJhbXNgIG9yIHNpbWlsYXIgZXhwcmVzc2lvbic7XG4gICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcykge1xuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWUpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgICAgIC8vIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHlcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZTtcbiAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KShyZXF1ZXN0U3RvcmUpO1xuICAgIH1cbiAgICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICAgIGlmIChtaXNzaW5nUHJvcGVydGllcyAmJiBtaXNzaW5nUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24ocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgfVxufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiAoMCwgX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIuY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldikoY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3IpO1xuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogKDAsIF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyLmNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYpKGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKTtcbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0FjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICc7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICsgYFxcYHBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdlcmUgbm90IGF2YWlsYWJsZSB0aHJvdWdoIGVudW1lcmF0aW9uIGAgKyBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBwcm9wZXJ0eSBuYW1lczogYCArIGAke2Rlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyl9LiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMocHJvcGVydGllcykge1xuICAgIHN3aXRjaChwcm9wZXJ0aWVzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRocm93IG5ldyBfaW52YXJpYW50ZXJyb3IuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyB0byBiZSBjYWxsZWQgd2l0aCBhIG5vbi1lbXB0eSBsaXN0IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYGA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYCBhbmQgXFxgJHtwcm9wZXJ0aWVzWzFdfVxcYGA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYFxcYCR7cHJvcGVydGllc1tpXX1cXGAsIGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAsIGFuZCBcXGAke3Byb3BlcnRpZXNbcHJvcGVydGllcy5sZW5ndGggLSAxXX1cXGBgO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUHJlcmVuZGVyUGFyYW1zRm9yQ2xpZW50U2VnbWVudCIsImNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhIiwiY3JlYXRlU2VydmVyUGFyYW1zRm9yUm91dGUiLCJjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JTZXJ2ZXJTZWdtZW50IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3JlZmxlY3QiLCJyZXF1aXJlIiwiX2R5bmFtaWNyZW5kZXJpbmciLCJfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbCIsIl9pbnZhcmlhbnRlcnJvciIsIl91dGlscyIsIl9keW5hbWljcmVuZGVyaW5ndXRpbHMiLCJfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlciIsIl9zY2hlZHVsZXIiLCJ1bmRlcmx5aW5nUGFyYW1zIiwid29ya1N0b3JlIiwid29ya1VuaXRTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ0eXBlIiwiY3JlYXRlUHJlcmVuZGVyUGFyYW1zIiwiY3JlYXRlUmVuZGVyUGFyYW1zIiwicHJlcmVuZGVyU3RvcmUiLCJmYWxsYmFja1BhcmFtcyIsImZhbGxiYWNrUm91dGVQYXJhbXMiLCJrZXkiLCJoYXMiLCJtYWtlSGFuZ2luZ1Byb21pc2UiLCJyZW5kZXJTaWduYWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImhhc1NvbWVGYWxsYmFja1BhcmFtcyIsIm1ha2VBYm9ydGluZ0V4b3RpY1BhcmFtcyIsInJvdXRlIiwibWFrZUVycm9yaW5nRXhvdGljUGFyYW1zIiwibWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzUHJlZmV0Y2hSZXF1ZXN0IiwibWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIkNhY2hlZFBhcmFtcyIsIldlYWtNYXAiLCJjYWNoZWRQYXJhbXMiLCJwcm9taXNlIiwic2V0Iiwia2V5cyIsImZvckVhY2giLCJwcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsImV4cHJlc3Npb24iLCJkZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzIiwiZXJyb3IiLCJjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvciIsImFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MiLCJuZXdWYWx1ZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYXVnbWVudGVkVW5kZXJseWluZyIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwiZHluYW1pY1RyYWNraW5nIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJzdG9yZSIsInNjaGVkdWxlSW1tZWRpYXRlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHVzaCIsImFkZCIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJyZWNlaXZlciIsInN5bmNJT0RldiIsIlJlZmxlY3RBZGFwdGVyIiwiZGVsZXRlIiwib3duS2V5cyIsIlJlZmxlY3QiLCJtaXNzaW5nUHJvcGVydGllcyIsInByZXJlbmRlclBoYXNlIiwicmVxdWVzdFN0b3JlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJsZW5ndGgiLCJ3YXJuRm9ySW5jb21wbGV0ZUVudW1lcmF0aW9uIiwid2FybkZvclN5bmNBY2Nlc3MiLCJub29wIiwiX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvciIsInByZWZpeCIsIkVycm9yIiwiZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsIkludmFyaWFudEVycm9yIiwiZGVzY3JpcHRpb24iLCJpIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/server/request/search-params.browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"createRenderSearchParamsFromClient\", ({\n  enumerable: true,\n  get: function () {\n    return createRenderSearchParamsFromClient;\n  }\n}));\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nfunction createRenderSearchParamsFromClient(underlyingSearchParams) {\n  if (true) {\n    return makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams);\n  } else {}\n}\nconst CachedSearchParams = new WeakMap();\nfunction makeUntrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  const promise = Promise.resolve(underlyingSearchParams);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      promise[prop] = underlyingSearchParams[prop];\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          warnForSyncAccess(expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      warnForSyncSpread();\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams);\n  CachedSearchParams.set(underlyingSearchParams, promise);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;\n      promise[prop] = underlyingSearchParams[prop];\n    }\n  });\n  return promise;\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : function warnForSyncAccess(expression) {\n  if (false) {}\n  console.error(`A searchParam property was accessed directly with ${expression}. ` + `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n};\nconst warnForSyncSpread =  false ? 0 : function warnForSyncSpread() {\n  if (false) {}\n  console.error(`The keys of \\`searchParams\\` were accessed directly. ` + `\\`searchParams\\` should be unwrapped with \\`React.use()\\` before accessing its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxzRUFBcUU7RUFDakVJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0Msa0NBQWtDO0VBQzdDO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsUUFBUSxHQUFHQyxtQkFBTyxDQUFDLDBJQUF3QyxDQUFDO0FBQ2xFLE1BQU1DLE1BQU0sR0FBR0QsbUJBQU8sQ0FBQyxxRkFBUyxDQUFDO0FBQ2pDLFNBQVNGLGtDQUFrQ0EsQ0FBQ0ksc0JBQXNCLEVBQUU7RUFDaEUsSUFBSUMsSUFBc0MsRUFBRTtJQUN4QyxPQUFPRyw4Q0FBOEMsQ0FBQ0osc0JBQXNCLENBQUM7RUFDakYsQ0FBQyxNQUFNLEVBRU47QUFDTDtBQUNBLE1BQU1NLGtCQUFrQixHQUFHLElBQUlDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hDLFNBQVNILDhDQUE4Q0EsQ0FBQ0osc0JBQXNCLEVBQUU7RUFDNUUsTUFBTVEsa0JBQWtCLEdBQUdGLGtCQUFrQixDQUFDWCxHQUFHLENBQUNLLHNCQUFzQixDQUFDO0VBQ3pFLElBQUlRLGtCQUFrQixFQUFFO0lBQ3BCLE9BQU9BLGtCQUFrQjtFQUM3QjtFQUNBLE1BQU1DLGlCQUFpQixHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQ25DLE1BQU1DLG1CQUFtQixHQUFHLEVBQUU7RUFDOUIsTUFBTUMsT0FBTyxHQUFHQyxPQUFPLENBQUNDLE9BQU8sQ0FBQ2Qsc0JBQXNCLENBQUM7RUFDdkRWLE1BQU0sQ0FBQ3lCLElBQUksQ0FBQ2Ysc0JBQXNCLENBQUMsQ0FBQ2dCLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQ2hELElBQUlsQixNQUFNLENBQUNtQixtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixJQUFJLENBQUMsRUFBRTtNQUN0QztNQUNBO01BQ0FOLG1CQUFtQixDQUFDUyxJQUFJLENBQUNILElBQUksQ0FBQztJQUNsQyxDQUFDLE1BQU07TUFDSFIsaUJBQWlCLENBQUNZLEdBQUcsQ0FBQ0osSUFBSSxDQUFDO01BQzNCTCxPQUFPLENBQUNLLElBQUksQ0FBQyxHQUFHakIsc0JBQXNCLENBQUNpQixJQUFJLENBQUM7SUFDaEQ7RUFDSixDQUFDLENBQUM7RUFDRixNQUFNSyxjQUFjLEdBQUcsSUFBSUMsS0FBSyxDQUFDWCxPQUFPLEVBQUU7SUFDdENqQixHQUFHQSxDQUFFNkIsTUFBTSxFQUFFUCxJQUFJLEVBQUVRLFFBQVEsRUFBRTtNQUN6QixJQUFJLE9BQU9SLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDMUIsSUFBSSxDQUFDbEIsTUFBTSxDQUFDbUIsbUJBQW1CLENBQUNDLEdBQUcsQ0FBQ0YsSUFBSSxDQUFDLEtBQUtSLGlCQUFpQixDQUFDVSxHQUFHLENBQUNGLElBQUksQ0FBQztRQUFJO1FBQzdFO1FBQ0FTLE9BQU8sQ0FBQ1AsR0FBRyxDQUFDSyxNQUFNLEVBQUVQLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO1VBQ2xDLE1BQU1VLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRTVCLE1BQU0sQ0FBQzZCLDRCQUE0QixFQUFFLGNBQWMsRUFBRVgsSUFBSSxDQUFDO1VBQ2pGWSxpQkFBaUIsQ0FBQ0YsVUFBVSxDQUFDO1FBQ2pDO01BQ0o7TUFDQSxPQUFPOUIsUUFBUSxDQUFDaUMsY0FBYyxDQUFDbkMsR0FBRyxDQUFDNkIsTUFBTSxFQUFFUCxJQUFJLEVBQUVRLFFBQVEsQ0FBQztJQUM5RCxDQUFDO0lBQ0RNLEdBQUdBLENBQUVQLE1BQU0sRUFBRVAsSUFBSSxFQUFFeEIsS0FBSyxFQUFFZ0MsUUFBUSxFQUFFO01BQ2hDLElBQUksT0FBT1IsSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUMxQlIsaUJBQWlCLENBQUN1QixNQUFNLENBQUNmLElBQUksQ0FBQztNQUNsQztNQUNBLE9BQU9TLE9BQU8sQ0FBQ0ssR0FBRyxDQUFDUCxNQUFNLEVBQUVQLElBQUksRUFBRXhCLEtBQUssRUFBRWdDLFFBQVEsQ0FBQztJQUNyRCxDQUFDO0lBQ0ROLEdBQUdBLENBQUVLLE1BQU0sRUFBRVAsSUFBSSxFQUFFO01BQ2YsSUFBSSxPQUFPQSxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ21CLG1CQUFtQixDQUFDQyxHQUFHLENBQUNGLElBQUksQ0FBQyxLQUFLUixpQkFBaUIsQ0FBQ1UsR0FBRyxDQUFDRixJQUFJLENBQUM7UUFBSTtRQUM3RTtRQUNBUyxPQUFPLENBQUNQLEdBQUcsQ0FBQ0ssTUFBTSxFQUFFUCxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtVQUNsQyxNQUFNVSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUU1QixNQUFNLENBQUNrQyxpQ0FBaUMsRUFBRSxjQUFjLEVBQUVoQixJQUFJLENBQUM7VUFDdEZZLGlCQUFpQixDQUFDRixVQUFVLENBQUM7UUFDakM7TUFDSjtNQUNBLE9BQU9ELE9BQU8sQ0FBQ1AsR0FBRyxDQUFDSyxNQUFNLEVBQUVQLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBQ0RpQixPQUFPQSxDQUFFVixNQUFNLEVBQUU7TUFDYlcsaUJBQWlCLENBQUMsQ0FBQztNQUNuQixPQUFPVCxPQUFPLENBQUNRLE9BQU8sQ0FBQ1YsTUFBTSxDQUFDO0lBQ2xDO0VBQ0osQ0FBQyxDQUFDO0VBQ0ZsQixrQkFBa0IsQ0FBQ3lCLEdBQUcsQ0FBQy9CLHNCQUFzQixFQUFFc0IsY0FBYyxDQUFDO0VBQzlELE9BQU9BLGNBQWM7QUFDekI7QUFDQSxTQUFTakIsK0JBQStCQSxDQUFDTCxzQkFBc0IsRUFBRTtFQUM3RCxNQUFNUSxrQkFBa0IsR0FBR0Ysa0JBQWtCLENBQUNYLEdBQUcsQ0FBQ0ssc0JBQXNCLENBQUM7RUFDekUsSUFBSVEsa0JBQWtCLEVBQUU7SUFDcEIsT0FBT0Esa0JBQWtCO0VBQzdCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsTUFBTUksT0FBTyxHQUFHQyxPQUFPLENBQUNDLE9BQU8sQ0FBQ2Qsc0JBQXNCLENBQUM7RUFDdkRNLGtCQUFrQixDQUFDeUIsR0FBRyxDQUFDL0Isc0JBQXNCLEVBQUVZLE9BQU8sQ0FBQztFQUN2RHRCLE1BQU0sQ0FBQ3lCLElBQUksQ0FBQ2Ysc0JBQXNCLENBQUMsQ0FBQ2dCLE9BQU8sQ0FBRUMsSUFBSSxJQUFHO0lBQ2hELElBQUlsQixNQUFNLENBQUNtQixtQkFBbUIsQ0FBQ0MsR0FBRyxDQUFDRixJQUFJLENBQUMsRUFBRTtNQUMxQztNQUNBO0lBQUEsQ0FDQyxNQUFNO01BQ0g7TUFDQUwsT0FBTyxDQUFDSyxJQUFJLENBQUMsR0FBR2pCLHNCQUFzQixDQUFDaUIsSUFBSSxDQUFDO0lBQ2hEO0VBQ0osQ0FBQyxDQUFDO0VBQ0YsT0FBT0wsT0FBTztBQUNsQjtBQUNBLE1BQU13QixJQUFJLEdBQUdBLENBQUEsS0FBSSxDQUFDLENBQUM7QUFDbkIsTUFBTVAsaUJBQWlCLEdBQUc1QixNQUFvRCxHQUFHbUMsQ0FBSSxHQUFHLFNBQVNQLGlCQUFpQkEsQ0FBQ0YsVUFBVSxFQUFFO0VBQzNILElBQUkxQixLQUFvRCxFQUFFLEVBRXpEO0VBQ0RxQyxPQUFPLENBQUNDLEtBQUssQ0FBRSxxREFBb0RaLFVBQVcsSUFBRyxHQUFJLDZGQUE0RixHQUFJLGdFQUErRCxDQUFDO0FBQ3pQLENBQUM7QUFDRCxNQUFNUSxpQkFBaUIsR0FBR2xDLE1BQW9ELEdBQUdtQyxDQUFJLEdBQUcsU0FBU0QsaUJBQWlCQSxDQUFBLEVBQUc7RUFDakgsSUFBSWxDLEtBQW9ELEVBQUUsRUFFekQ7RUFDRHFDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFFLHVEQUFzRCxHQUFJLDZGQUE0RixHQUFJLGdFQUErRCxDQUFDO0FBQzdPLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zLmJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH1cbn0pO1xuY29uc3QgX3JlZmxlY3QgPSByZXF1aXJlKFwiLi4vd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL3JlZmxlY3RcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQodW5kZXJseWluZ1NlYXJjaFBhcmFtcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWRTZWFyY2hQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKSB7XG4gICAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IHByb3hpZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVucHJveGllZFByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIE9iamVjdC5rZXlzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgIGlmIChfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgICAgICB1bnByb3hpZWRQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5hZGQocHJvcCk7XG4gICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1NlYXJjaFBhcmFtc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICAgICAgZ2V0ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiYgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fCAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgKHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJiAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8IC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZUhhc0NoZWNraW5nU3RyaW5nUHJvcGVydHkpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3MoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgd2FybkZvclN5bmNTcHJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBzZWFyY2hQYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1NlYXJjaFBhcmFtc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiBmdW5jdGlvbiB3YXJuRm9yU3luY0FjY2VzcyhleHByZXNzaW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBBIHNlYXJjaFBhcmFtIHByb3BlcnR5IHdhcyBhY2Nlc3NlZCBkaXJlY3RseSB3aXRoICR7ZXhwcmVzc2lvbn0uIGAgKyBgXFxgc2VhcmNoUGFyYW1zXFxgIHNob3VsZCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59O1xuY29uc3Qgd2FybkZvclN5bmNTcHJlYWQgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTID8gbm9vcCA6IGZ1bmN0aW9uIHdhcm5Gb3JTeW5jU3ByZWFkKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcihgVGhlIGtleXMgb2YgXFxgc2VhcmNoUGFyYW1zXFxgIHdlcmUgYWNjZXNzZWQgZGlyZWN0bHkuIGAgKyBgXFxgc2VhcmNoUGFyYW1zXFxgIHNob3VsZCBiZSB1bndyYXBwZWQgd2l0aCBcXGBSZWFjdC51c2UoKVxcYCBiZWZvcmUgYWNjZXNzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2gtcGFyYW1zLmJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJfcmVmbGVjdCIsInJlcXVpcmUiLCJfdXRpbHMiLCJ1bmRlcmx5aW5nU2VhcmNoUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyIsIm1ha2VVbnRyYWNrZWRFeG90aWNTZWFyY2hQYXJhbXMiLCJDYWNoZWRTZWFyY2hQYXJhbXMiLCJXZWFrTWFwIiwiY2FjaGVkU2VhcmNoUGFyYW1zIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwia2V5cyIsImZvckVhY2giLCJwcm9wIiwid2VsbEtub3duUHJvcGVydGllcyIsImhhcyIsInB1c2giLCJhZGQiLCJwcm94aWVkUHJvbWlzZSIsIlByb3h5IiwidGFyZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJ3YXJuRm9yU3luY0FjY2VzcyIsIlJlZmxlY3RBZGFwdGVyIiwic2V0IiwiZGVsZXRlIiwiZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5Iiwib3duS2V5cyIsIndhcm5Gb3JTeW5jU3ByZWFkIiwibm9vcCIsIl9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MiLCJjb25zb2xlIiwiZXJyb3IiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/server/request/search-params.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  createPrerenderSearchParamsForClientPage: function () {\n    return createPrerenderSearchParamsForClientPage;\n  },\n  createSearchParamsFromClient: function () {\n    return createSearchParamsFromClient;\n  },\n  createServerSearchParamsForMetadata: function () {\n    return createServerSearchParamsForMetadata;\n  },\n  createServerSearchParamsForServerPage: function () {\n    return createServerSearchParamsForServerPage;\n  }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createSearchParamsFromClient(underlyingSearchParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nconst createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\nfunction createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createPrerenderSearchParams(workStore, workUnitStore);\n      default:\n    }\n  }\n  return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nfunction createPrerenderSearchParamsForClientPage(workStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  }\n  const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (prerenderStore && prerenderStore.type === 'prerender') {\n    // dynamicIO Prerender\n    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n    // the promise to ensure the RSC side is considered dynamic\n    return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n  }\n  // We're prerendering in a mode that does not aborts. We resolve the promise without\n  // any tracking because we're just transporting a value from server to client where the tracking\n  // will be applied.\n  return Promise.resolve({});\n}\nfunction createPrerenderSearchParams(workStore, prerenderStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  }\n  if (prerenderStore.type === 'prerender') {\n    // We are in a dynamicIO (PPR or otherwise) prerender\n    return makeAbortingExoticSearchParams(workStore.route, prerenderStore);\n  }\n  // The remaining cases are prerender-ppr and prerender-legacy\n  // We are in a legacy static generation and need to interrupt the prerender\n  // when search params are accessed.\n  return makeErroringExoticSearchParams(workStore, prerenderStore);\n}\nfunction createRenderSearchParams(underlyingSearchParams, workStore) {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({});\n  } else {\n    if ( true && !workStore.isPrefetchRequest) {\n      return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\n    } else {\n      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);\n    }\n  }\n}\nconst CachedSearchParams = new WeakMap();\nfunction makeAbortingExoticSearchParams(route, prerenderStore) {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return _reflect.ReflectAdapter.get(target, prop, receiver);\n      }\n      switch (prop) {\n        case 'then':\n          {\n            const expression = '`await searchParams`, `searchParams.then`, or similar';\n            (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        case 'status':\n          {\n            const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n            (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule':\n          {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        default:\n          {\n            if (typeof prop === 'string') {\n              const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n              const error = createSearchAccessError(route, expression);\n              (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n        const error = createSearchAccessError(route, expression);\n        (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n      }\n      return _reflect.ReflectAdapter.has(target, prop);\n    },\n    ownKeys() {\n      const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n      const error = createSearchAccessError(route, expression);\n      (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n    }\n  });\n  CachedSearchParams.set(prerenderStore, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeErroringExoticSearchParams(workStore, prerenderStore) {\n  const cachedSearchParams = CachedSearchParams.get(workStore);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const underlyingSearchParams = {};\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams);\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return _reflect.ReflectAdapter.get(target, prop, receiver);\n      }\n      switch (prop) {\n        // Object prototype\n        case 'hasOwnProperty':\n        case 'isPrototypeOf':\n        case 'propertyIsEnumerable':\n        case 'toString':\n        case 'valueOf':\n        case 'toLocaleString':\n        // Promise prototype\n        // fallthrough\n        case 'catch':\n        case 'finally':\n        // Common tested properties\n        // fallthrough\n        case 'toJSON':\n        case '$$typeof':\n        case '__esModule':\n          {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n        case 'then':\n          {\n            const expression = '`await searchParams`, `searchParams.then`, or similar';\n            if (workStore.dynamicShouldError) {\n              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n            return;\n          }\n        case 'status':\n          {\n            const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n            if (workStore.dynamicShouldError) {\n              (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n              // PPR Prerender (no dynamicIO)\n              (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n              // Legacy Prerender\n              (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n            return;\n          }\n        default:\n          {\n            if (typeof prop === 'string') {\n              const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n              if (workStore.dynamicShouldError) {\n                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n              } else if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n              } else {\n                // Legacy Prerender\n                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n              }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n          }\n      }\n    },\n    has(target, prop) {\n      // We don't expect key checking to be used except for testing the existence of\n      // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n      // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n      // you are testing whether the searchParams has a 'then' property.\n      if (typeof prop === 'string') {\n        const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n        if (workStore.dynamicShouldError) {\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no dynamicIO)\n          (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n        } else {\n          // Legacy Prerender\n          (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n        }\n        return false;\n      }\n      return _reflect.ReflectAdapter.has(target, prop);\n    },\n    ownKeys() {\n      const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n      if (workStore.dynamicShouldError) {\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n      } else if (prerenderStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n      } else {\n        // Legacy Prerender\n        (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n      }\n    }\n  });\n  CachedSearchParams.set(workStore, proxiedPromise);\n  return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams, store) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams);\n  CachedSearchParams.set(underlyingSearchParams, promise);\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    switch (prop) {\n      // Object prototype\n      case 'hasOwnProperty':\n      case 'isPrototypeOf':\n      case 'propertyIsEnumerable':\n      case 'toString':\n      case 'valueOf':\n      case 'toLocaleString':\n      // Promise prototype\n      // fallthrough\n      case 'then':\n      case 'catch':\n      case 'finally':\n      // React Promise extension\n      // fallthrough\n      case 'status':\n      // Common tested properties\n      // fallthrough\n      case 'toJSON':\n      case '$$typeof':\n      case '__esModule':\n        {\n          break;\n        }\n      default:\n        {\n          Object.defineProperty(promise, prop, {\n            get() {\n              const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n              (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n              return underlyingSearchParams[prop];\n            },\n            set(value) {\n              Object.defineProperty(promise, prop, {\n                value,\n                writable: true,\n                enumerable: true\n              });\n            },\n            enumerable: true,\n            configurable: true\n          });\n        }\n    }\n  });\n  return promise;\n}\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n  if (cachedSearchParams) {\n    return cachedSearchParams;\n  }\n  const proxiedProperties = new Set();\n  const unproxiedProperties = [];\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false;\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n        }\n        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n        (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n      }\n      return Reflect.ownKeys(target);\n    }\n  });\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = new Promise(resolve => (0, _scheduler.scheduleImmediate)(() => resolve(underlyingSearchParams)));\n  promise.then(() => {\n    promiseInitialized = true;\n  });\n  Object.keys(underlyingSearchParams).forEach(prop => {\n    if (_utils.wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n      unproxiedProperties.push(prop);\n    } else {\n      proxiedProperties.add(prop);\n      Object.defineProperty(promise, prop, {\n        get() {\n          return proxiedUnderlying[prop];\n        },\n        set(newValue) {\n          Object.defineProperty(promise, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true\n          });\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  });\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`';\n        (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n      }\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return _reflect.ReflectAdapter.get(target, prop, receiver);\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop);\n      }\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) ||\n        // We are accessing a property that doesn't exist on the promise nor\n        // the underlying searchParams.\n        Reflect.has(target, prop) === false)) {\n          const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n          syncIODev(store.route, expression);\n        }\n      }\n      return Reflect.has(target, prop);\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar';\n      syncIODev(store.route, expression, unproxiedProperties);\n      return Reflect.ownKeys(target);\n    }\n  });\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n  return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n  // In all cases we warn normally\n  if (missingProperties && missingProperties.length > 0) {\n    warnForIncompleteEnumeration(route, expression, missingProperties);\n  } else {\n    warnForSyncAccess(route, expression);\n  }\n  const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n  if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore;\n    (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n  }\n}\nconst noop = () => {};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createSearchAccessError(route, expression) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route ';\n  return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n  switch (properties.length) {\n    case 0:\n      throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n    case 1:\n      return `\\`${properties[0]}\\``;\n    case 2:\n      return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n    default:\n      {\n        let description = '';\n        for (let i = 0; i < properties.length - 1; i++) {\n          description += `\\`${properties[i]}\\`, `;\n        }\n        description += `, and \\`${properties[properties.length - 1]}\\``;\n        return description;\n      }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRixDQUFDLEtBQUtDLENBS0wsQ0FBQztBQUNGLFNBQVNLLE9BQU9BLENBQUNDLE1BQU0sRUFBRUMsR0FBRyxFQUFFO0VBQzFCLEtBQUksSUFBSUMsSUFBSSxJQUFJRCxHQUFHLEVBQUNYLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUyxNQUFNLEVBQUVFLElBQUksRUFBRTtJQUNwREMsVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRUgsR0FBRyxDQUFDQyxJQUFJO0VBQ2pCLENBQUMsQ0FBQztBQUNOO0FBQ0FILE9BQU8sQ0FBQ1AsT0FBTyxFQUFFO0VBQ2JHLHdDQUF3QyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUNqRCxPQUFPQSx3Q0FBd0M7RUFDbkQsQ0FBQztFQUNEQyw0QkFBNEIsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDckMsT0FBT0EsNEJBQTRCO0VBQ3ZDLENBQUM7RUFDREMsbUNBQW1DLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzVDLE9BQU9BLG1DQUFtQztFQUM5QyxDQUFDO0VBQ0RDLHFDQUFxQyxFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM5QyxPQUFPQSxxQ0FBcUM7RUFDaEQ7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyxRQUFRLEdBQUdDLG1CQUFPLENBQUMsMElBQXdDLENBQUM7QUFDbEUsTUFBTUMsaUJBQWlCLEdBQUdELG1CQUFPLENBQUMsNEhBQWlDLENBQUM7QUFDcEUsTUFBTUUsNkJBQTZCLEdBQUdGLG1CQUFPLENBQUMsK0lBQWdELENBQUM7QUFDL0YsTUFBTUcsZUFBZSxHQUFHSCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLE1BQU1JLHNCQUFzQixHQUFHSixtQkFBTyxDQUFDLGtIQUE0QixDQUFDO0FBQ3BFLE1BQU1LLHlDQUF5QyxHQUFHTCxtQkFBTyxDQUFDLGdLQUFtRCxDQUFDO0FBQzlHLE1BQU1NLE1BQU0sR0FBR04sbUJBQU8sQ0FBQyxxRkFBUyxDQUFDO0FBQ2pDLE1BQU1PLFVBQVUsR0FBR1AsbUJBQU8sQ0FBQywwRkFBcUIsQ0FBQztBQUNqRCxTQUFTViw0QkFBNEJBLENBQUNrQixzQkFBc0IsRUFBRUMsU0FBUyxFQUFFO0VBQ3JFLE1BQU1DLGFBQWEsR0FBR1IsNkJBQTZCLENBQUNTLG9CQUFvQixDQUFDQyxRQUFRLENBQUMsQ0FBQztFQUNuRixJQUFJRixhQUFhLEVBQUU7SUFDZixRQUFPQSxhQUFhLENBQUNHLElBQUk7TUFDckIsS0FBSyxXQUFXO01BQ2hCLEtBQUssZUFBZTtNQUNwQixLQUFLLGtCQUFrQjtRQUNuQixPQUFPQywyQkFBMkIsQ0FBQ0wsU0FBUyxFQUFFQyxhQUFhLENBQUM7TUFDaEU7SUFDSjtFQUNKO0VBQ0EsT0FBT0ssd0JBQXdCLENBQUNQLHNCQUFzQixFQUFFQyxTQUFTLENBQUM7QUFDdEU7QUFDQSxNQUFNbEIsbUNBQW1DLEdBQUdDLHFDQUFxQztBQUNqRixTQUFTQSxxQ0FBcUNBLENBQUNnQixzQkFBc0IsRUFBRUMsU0FBUyxFQUFFO0VBQzlFLE1BQU1DLGFBQWEsR0FBR1IsNkJBQTZCLENBQUNTLG9CQUFvQixDQUFDQyxRQUFRLENBQUMsQ0FBQztFQUNuRixJQUFJRixhQUFhLEVBQUU7SUFDZixRQUFPQSxhQUFhLENBQUNHLElBQUk7TUFDckIsS0FBSyxXQUFXO01BQ2hCLEtBQUssZUFBZTtNQUNwQixLQUFLLGtCQUFrQjtRQUNuQixPQUFPQywyQkFBMkIsQ0FBQ0wsU0FBUyxFQUFFQyxhQUFhLENBQUM7TUFDaEU7SUFDSjtFQUNKO0VBQ0EsT0FBT0ssd0JBQXdCLENBQUNQLHNCQUFzQixFQUFFQyxTQUFTLENBQUM7QUFDdEU7QUFDQSxTQUFTcEIsd0NBQXdDQSxDQUFDb0IsU0FBUyxFQUFFO0VBQ3pELElBQUlBLFNBQVMsQ0FBQ08sV0FBVyxFQUFFO0lBQ3ZCO0lBQ0E7SUFDQSxPQUFPQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUM5QjtFQUNBLE1BQU1DLGNBQWMsR0FBR2pCLDZCQUE2QixDQUFDUyxvQkFBb0IsQ0FBQ0MsUUFBUSxDQUFDLENBQUM7RUFDcEYsSUFBSU8sY0FBYyxJQUFJQSxjQUFjLENBQUNOLElBQUksS0FBSyxXQUFXLEVBQUU7SUFDdkQ7SUFDQTtJQUNBO0lBQ0EsT0FBTyxDQUFDLENBQUMsRUFBRVQsc0JBQXNCLENBQUNnQixrQkFBa0IsRUFBRUQsY0FBYyxDQUFDRSxZQUFZLEVBQUUsZ0JBQWdCLENBQUM7RUFDeEc7RUFDQTtFQUNBO0VBQ0E7RUFDQSxPQUFPSixPQUFPLENBQUNDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QjtBQUNBLFNBQVNKLDJCQUEyQkEsQ0FBQ0wsU0FBUyxFQUFFVSxjQUFjLEVBQUU7RUFDNUQsSUFBSVYsU0FBUyxDQUFDTyxXQUFXLEVBQUU7SUFDdkI7SUFDQTtJQUNBLE9BQU9DLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzlCO0VBQ0EsSUFBSUMsY0FBYyxDQUFDTixJQUFJLEtBQUssV0FBVyxFQUFFO0lBQ3JDO0lBQ0EsT0FBT1MsOEJBQThCLENBQUNiLFNBQVMsQ0FBQ2MsS0FBSyxFQUFFSixjQUFjLENBQUM7RUFDMUU7RUFDQTtFQUNBO0VBQ0E7RUFDQSxPQUFPSyw4QkFBOEIsQ0FBQ2YsU0FBUyxFQUFFVSxjQUFjLENBQUM7QUFDcEU7QUFDQSxTQUFTSix3QkFBd0JBLENBQUNQLHNCQUFzQixFQUFFQyxTQUFTLEVBQUU7RUFDakUsSUFBSUEsU0FBUyxDQUFDTyxXQUFXLEVBQUU7SUFDdkI7SUFDQTtJQUNBLE9BQU9DLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzlCLENBQUMsTUFBTTtJQUNILElBQUlPLEtBQXNDLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ21CLGlCQUFpQixFQUFFO01BQ3hFLE9BQU9DLHVEQUF1RCxDQUFDckIsc0JBQXNCLEVBQUVDLFNBQVMsQ0FBQztJQUNyRyxDQUFDLE1BQU07TUFDSCxPQUFPcUIsK0JBQStCLENBQUN0QixzQkFBc0IsRUFBRUMsU0FBUyxDQUFDO0lBQzdFO0VBQ0o7QUFDSjtBQUNBLE1BQU1zQixrQkFBa0IsR0FBRyxJQUFJQyxPQUFPLENBQUMsQ0FBQztBQUN4QyxTQUFTViw4QkFBOEJBLENBQUNDLEtBQUssRUFBRUosY0FBYyxFQUFFO0VBQzNELE1BQU1jLGtCQUFrQixHQUFHRixrQkFBa0IsQ0FBQ2pDLEdBQUcsQ0FBQ3FCLGNBQWMsQ0FBQztFQUNqRSxJQUFJYyxrQkFBa0IsRUFBRTtJQUNwQixPQUFPQSxrQkFBa0I7RUFDN0I7RUFDQSxNQUFNQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUU5QixzQkFBc0IsQ0FBQ2dCLGtCQUFrQixFQUFFRCxjQUFjLENBQUNFLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQztFQUM3RyxNQUFNYyxjQUFjLEdBQUcsSUFBSUMsS0FBSyxDQUFDRixPQUFPLEVBQUU7SUFDdENwQyxHQUFHQSxDQUFFSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsRUFBRTtNQUN6QixJQUFJdEQsTUFBTSxDQUFDdUQsTUFBTSxDQUFDTCxPQUFPLEVBQUVHLElBQUksQ0FBQyxFQUFFO1FBQzlCO1FBQ0E7UUFDQTtRQUNBLE9BQU90QyxRQUFRLENBQUN5QyxjQUFjLENBQUMxQyxHQUFHLENBQUNKLE1BQU0sRUFBRTJDLElBQUksRUFBRUMsUUFBUSxDQUFDO01BQzlEO01BQ0EsUUFBT0QsSUFBSTtRQUNQLEtBQUssTUFBTTtVQUNQO1lBQ0ksTUFBTUksVUFBVSxHQUFHLHVEQUF1RDtZQUMxRSxDQUFDLENBQUMsRUFBRXhDLGlCQUFpQixDQUFDeUMscUJBQXFCLEVBQUVELFVBQVUsRUFBRXRCLGNBQWMsQ0FBQztZQUN4RSxPQUFPcEIsUUFBUSxDQUFDeUMsY0FBYyxDQUFDMUMsR0FBRyxDQUFDSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsQ0FBQztVQUM5RDtRQUNKLEtBQUssUUFBUTtVQUNUO1lBQ0ksTUFBTUcsVUFBVSxHQUFHLHdEQUF3RDtZQUMzRSxDQUFDLENBQUMsRUFBRXhDLGlCQUFpQixDQUFDeUMscUJBQXFCLEVBQUVELFVBQVUsRUFBRXRCLGNBQWMsQ0FBQztZQUN4RSxPQUFPcEIsUUFBUSxDQUFDeUMsY0FBYyxDQUFDMUMsR0FBRyxDQUFDSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsQ0FBQztVQUM5RDtRQUNKO1FBQ0EsS0FBSyxnQkFBZ0I7UUFDckIsS0FBSyxlQUFlO1FBQ3BCLEtBQUssc0JBQXNCO1FBQzNCLEtBQUssVUFBVTtRQUNmLEtBQUssU0FBUztRQUNkLEtBQUssZ0JBQWdCO1FBQ3JCO1FBQ0E7UUFDQSxLQUFLLE9BQU87UUFDWixLQUFLLFNBQVM7UUFDZDtRQUNBO1FBQ0EsS0FBSyxRQUFRO1FBQ2IsS0FBSyxVQUFVO1FBQ2YsS0FBSyxZQUFZO1VBQ2I7WUFDSTtZQUNBO1lBQ0EsT0FBT3ZDLFFBQVEsQ0FBQ3lDLGNBQWMsQ0FBQzFDLEdBQUcsQ0FBQ0osTUFBTSxFQUFFMkMsSUFBSSxFQUFFQyxRQUFRLENBQUM7VUFDOUQ7UUFDSjtVQUNJO1lBQ0ksSUFBSSxPQUFPRCxJQUFJLEtBQUssUUFBUSxFQUFFO2NBQzFCLE1BQU1JLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQ3FDLDRCQUE0QixFQUFFLGNBQWMsRUFBRU4sSUFBSSxDQUFDO2NBQ2pGLE1BQU1PLEtBQUssR0FBR0MsdUJBQXVCLENBQUN0QixLQUFLLEVBQUVrQixVQUFVLENBQUM7Y0FDeEQsQ0FBQyxDQUFDLEVBQUV4QyxpQkFBaUIsQ0FBQzZDLDJDQUEyQyxFQUFFdkIsS0FBSyxFQUFFa0IsVUFBVSxFQUFFRyxLQUFLLEVBQUV6QixjQUFjLENBQUM7WUFDaEg7WUFDQSxPQUFPcEIsUUFBUSxDQUFDeUMsY0FBYyxDQUFDMUMsR0FBRyxDQUFDSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsQ0FBQztVQUM5RDtNQUNSO0lBQ0osQ0FBQztJQUNEUyxHQUFHQSxDQUFFckQsTUFBTSxFQUFFMkMsSUFBSSxFQUFFO01BQ2Y7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJLE9BQU9BLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDMUIsTUFBTUksVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFbkMsTUFBTSxDQUFDMEMsaUNBQWlDLEVBQUUsY0FBYyxFQUFFWCxJQUFJLENBQUM7UUFDdEYsTUFBTU8sS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ3RCLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztRQUN4RCxDQUFDLENBQUMsRUFBRXhDLGlCQUFpQixDQUFDNkMsMkNBQTJDLEVBQUV2QixLQUFLLEVBQUVrQixVQUFVLEVBQUVHLEtBQUssRUFBRXpCLGNBQWMsQ0FBQztNQUNoSDtNQUNBLE9BQU9wQixRQUFRLENBQUN5QyxjQUFjLENBQUNPLEdBQUcsQ0FBQ3JELE1BQU0sRUFBRTJDLElBQUksQ0FBQztJQUNwRCxDQUFDO0lBQ0RZLE9BQU9BLENBQUEsRUFBSTtNQUNQLE1BQU1SLFVBQVUsR0FBRyw4REFBOEQ7TUFDakYsTUFBTUcsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ3RCLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztNQUN4RCxDQUFDLENBQUMsRUFBRXhDLGlCQUFpQixDQUFDNkMsMkNBQTJDLEVBQUV2QixLQUFLLEVBQUVrQixVQUFVLEVBQUVHLEtBQUssRUFBRXpCLGNBQWMsQ0FBQztJQUNoSDtFQUNKLENBQUMsQ0FBQztFQUNGWSxrQkFBa0IsQ0FBQ21CLEdBQUcsQ0FBQy9CLGNBQWMsRUFBRWdCLGNBQWMsQ0FBQztFQUN0RCxPQUFPQSxjQUFjO0FBQ3pCO0FBQ0EsU0FBU1gsOEJBQThCQSxDQUFDZixTQUFTLEVBQUVVLGNBQWMsRUFBRTtFQUMvRCxNQUFNYyxrQkFBa0IsR0FBR0Ysa0JBQWtCLENBQUNqQyxHQUFHLENBQUNXLFNBQVMsQ0FBQztFQUM1RCxJQUFJd0Isa0JBQWtCLEVBQUU7SUFDcEIsT0FBT0Esa0JBQWtCO0VBQzdCO0VBQ0EsTUFBTXpCLHNCQUFzQixHQUFHLENBQUMsQ0FBQztFQUNqQztFQUNBO0VBQ0E7RUFDQSxNQUFNMEIsT0FBTyxHQUFHakIsT0FBTyxDQUFDQyxPQUFPLENBQUNWLHNCQUFzQixDQUFDO0VBQ3ZELE1BQU0yQixjQUFjLEdBQUcsSUFBSUMsS0FBSyxDQUFDRixPQUFPLEVBQUU7SUFDdENwQyxHQUFHQSxDQUFFSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsRUFBRTtNQUN6QixJQUFJdEQsTUFBTSxDQUFDdUQsTUFBTSxDQUFDTCxPQUFPLEVBQUVHLElBQUksQ0FBQyxFQUFFO1FBQzlCO1FBQ0E7UUFDQTtRQUNBLE9BQU90QyxRQUFRLENBQUN5QyxjQUFjLENBQUMxQyxHQUFHLENBQUNKLE1BQU0sRUFBRTJDLElBQUksRUFBRUMsUUFBUSxDQUFDO01BQzlEO01BQ0EsUUFBT0QsSUFBSTtRQUNQO1FBQ0EsS0FBSyxnQkFBZ0I7UUFDckIsS0FBSyxlQUFlO1FBQ3BCLEtBQUssc0JBQXNCO1FBQzNCLEtBQUssVUFBVTtRQUNmLEtBQUssU0FBUztRQUNkLEtBQUssZ0JBQWdCO1FBQ3JCO1FBQ0E7UUFDQSxLQUFLLE9BQU87UUFDWixLQUFLLFNBQVM7UUFDZDtRQUNBO1FBQ0EsS0FBSyxRQUFRO1FBQ2IsS0FBSyxVQUFVO1FBQ2YsS0FBSyxZQUFZO1VBQ2I7WUFDSTtZQUNBO1lBQ0EsT0FBT3RDLFFBQVEsQ0FBQ3lDLGNBQWMsQ0FBQzFDLEdBQUcsQ0FBQ0osTUFBTSxFQUFFMkMsSUFBSSxFQUFFQyxRQUFRLENBQUM7VUFDOUQ7UUFDSixLQUFLLE1BQU07VUFDUDtZQUNJLE1BQU1HLFVBQVUsR0FBRyx1REFBdUQ7WUFDMUUsSUFBSWhDLFNBQVMsQ0FBQzBDLGtCQUFrQixFQUFFO2NBQzlCLENBQUMsQ0FBQyxFQUFFN0MsTUFBTSxDQUFDOEMscURBQXFELEVBQUUzQyxTQUFTLENBQUNjLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztZQUNsRyxDQUFDLE1BQU0sSUFBSXRCLGNBQWMsQ0FBQ04sSUFBSSxLQUFLLGVBQWUsRUFBRTtjQUNoRDtjQUNBLENBQUMsQ0FBQyxFQUFFWixpQkFBaUIsQ0FBQ29ELG9CQUFvQixFQUFFNUMsU0FBUyxDQUFDYyxLQUFLLEVBQUVrQixVQUFVLEVBQUV0QixjQUFjLENBQUNtQyxlQUFlLENBQUM7WUFDNUcsQ0FBQyxNQUFNO2NBQ0g7Y0FDQSxDQUFDLENBQUMsRUFBRXJELGlCQUFpQixDQUFDc0QsZ0NBQWdDLEVBQUVkLFVBQVUsRUFBRWhDLFNBQVMsRUFBRVUsY0FBYyxDQUFDO1lBQ2xHO1lBQ0E7VUFDSjtRQUNKLEtBQUssUUFBUTtVQUNUO1lBQ0ksTUFBTXNCLFVBQVUsR0FBRyx3REFBd0Q7WUFDM0UsSUFBSWhDLFNBQVMsQ0FBQzBDLGtCQUFrQixFQUFFO2NBQzlCLENBQUMsQ0FBQyxFQUFFN0MsTUFBTSxDQUFDOEMscURBQXFELEVBQUUzQyxTQUFTLENBQUNjLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztZQUNsRyxDQUFDLE1BQU0sSUFBSXRCLGNBQWMsQ0FBQ04sSUFBSSxLQUFLLGVBQWUsRUFBRTtjQUNoRDtjQUNBLENBQUMsQ0FBQyxFQUFFWixpQkFBaUIsQ0FBQ29ELG9CQUFvQixFQUFFNUMsU0FBUyxDQUFDYyxLQUFLLEVBQUVrQixVQUFVLEVBQUV0QixjQUFjLENBQUNtQyxlQUFlLENBQUM7WUFDNUcsQ0FBQyxNQUFNO2NBQ0g7Y0FDQSxDQUFDLENBQUMsRUFBRXJELGlCQUFpQixDQUFDc0QsZ0NBQWdDLEVBQUVkLFVBQVUsRUFBRWhDLFNBQVMsRUFBRVUsY0FBYyxDQUFDO1lBQ2xHO1lBQ0E7VUFDSjtRQUNKO1VBQ0k7WUFDSSxJQUFJLE9BQU9rQixJQUFJLEtBQUssUUFBUSxFQUFFO2NBQzFCLE1BQU1JLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQ3FDLDRCQUE0QixFQUFFLGNBQWMsRUFBRU4sSUFBSSxDQUFDO2NBQ2pGLElBQUk1QixTQUFTLENBQUMwQyxrQkFBa0IsRUFBRTtnQkFDOUIsQ0FBQyxDQUFDLEVBQUU3QyxNQUFNLENBQUM4QyxxREFBcUQsRUFBRTNDLFNBQVMsQ0FBQ2MsS0FBSyxFQUFFa0IsVUFBVSxDQUFDO2NBQ2xHLENBQUMsTUFBTSxJQUFJdEIsY0FBYyxDQUFDTixJQUFJLEtBQUssZUFBZSxFQUFFO2dCQUNoRDtnQkFDQSxDQUFDLENBQUMsRUFBRVosaUJBQWlCLENBQUNvRCxvQkFBb0IsRUFBRTVDLFNBQVMsQ0FBQ2MsS0FBSyxFQUFFa0IsVUFBVSxFQUFFdEIsY0FBYyxDQUFDbUMsZUFBZSxDQUFDO2NBQzVHLENBQUMsTUFBTTtnQkFDSDtnQkFDQSxDQUFDLENBQUMsRUFBRXJELGlCQUFpQixDQUFDc0QsZ0NBQWdDLEVBQUVkLFVBQVUsRUFBRWhDLFNBQVMsRUFBRVUsY0FBYyxDQUFDO2NBQ2xHO1lBQ0o7WUFDQSxPQUFPcEIsUUFBUSxDQUFDeUMsY0FBYyxDQUFDMUMsR0FBRyxDQUFDSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsQ0FBQztVQUM5RDtNQUNSO0lBQ0osQ0FBQztJQUNEUyxHQUFHQSxDQUFFckQsTUFBTSxFQUFFMkMsSUFBSSxFQUFFO01BQ2Y7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJLE9BQU9BLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDMUIsTUFBTUksVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFbkMsTUFBTSxDQUFDMEMsaUNBQWlDLEVBQUUsY0FBYyxFQUFFWCxJQUFJLENBQUM7UUFDdEYsSUFBSTVCLFNBQVMsQ0FBQzBDLGtCQUFrQixFQUFFO1VBQzlCLENBQUMsQ0FBQyxFQUFFN0MsTUFBTSxDQUFDOEMscURBQXFELEVBQUUzQyxTQUFTLENBQUNjLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztRQUNsRyxDQUFDLE1BQU0sSUFBSXRCLGNBQWMsQ0FBQ04sSUFBSSxLQUFLLGVBQWUsRUFBRTtVQUNoRDtVQUNBLENBQUMsQ0FBQyxFQUFFWixpQkFBaUIsQ0FBQ29ELG9CQUFvQixFQUFFNUMsU0FBUyxDQUFDYyxLQUFLLEVBQUVrQixVQUFVLEVBQUV0QixjQUFjLENBQUNtQyxlQUFlLENBQUM7UUFDNUcsQ0FBQyxNQUFNO1VBQ0g7VUFDQSxDQUFDLENBQUMsRUFBRXJELGlCQUFpQixDQUFDc0QsZ0NBQWdDLEVBQUVkLFVBQVUsRUFBRWhDLFNBQVMsRUFBRVUsY0FBYyxDQUFDO1FBQ2xHO1FBQ0EsT0FBTyxLQUFLO01BQ2hCO01BQ0EsT0FBT3BCLFFBQVEsQ0FBQ3lDLGNBQWMsQ0FBQ08sR0FBRyxDQUFDckQsTUFBTSxFQUFFMkMsSUFBSSxDQUFDO0lBQ3BELENBQUM7SUFDRFksT0FBT0EsQ0FBQSxFQUFJO01BQ1AsTUFBTVIsVUFBVSxHQUFHLDhEQUE4RDtNQUNqRixJQUFJaEMsU0FBUyxDQUFDMEMsa0JBQWtCLEVBQUU7UUFDOUIsQ0FBQyxDQUFDLEVBQUU3QyxNQUFNLENBQUM4QyxxREFBcUQsRUFBRTNDLFNBQVMsQ0FBQ2MsS0FBSyxFQUFFa0IsVUFBVSxDQUFDO01BQ2xHLENBQUMsTUFBTSxJQUFJdEIsY0FBYyxDQUFDTixJQUFJLEtBQUssZUFBZSxFQUFFO1FBQ2hEO1FBQ0EsQ0FBQyxDQUFDLEVBQUVaLGlCQUFpQixDQUFDb0Qsb0JBQW9CLEVBQUU1QyxTQUFTLENBQUNjLEtBQUssRUFBRWtCLFVBQVUsRUFBRXRCLGNBQWMsQ0FBQ21DLGVBQWUsQ0FBQztNQUM1RyxDQUFDLE1BQU07UUFDSDtRQUNBLENBQUMsQ0FBQyxFQUFFckQsaUJBQWlCLENBQUNzRCxnQ0FBZ0MsRUFBRWQsVUFBVSxFQUFFaEMsU0FBUyxFQUFFVSxjQUFjLENBQUM7TUFDbEc7SUFDSjtFQUNKLENBQUMsQ0FBQztFQUNGWSxrQkFBa0IsQ0FBQ21CLEdBQUcsQ0FBQ3pDLFNBQVMsRUFBRTBCLGNBQWMsQ0FBQztFQUNqRCxPQUFPQSxjQUFjO0FBQ3pCO0FBQ0EsU0FBU0wsK0JBQStCQSxDQUFDdEIsc0JBQXNCLEVBQUVnRCxLQUFLLEVBQUU7RUFDcEUsTUFBTXZCLGtCQUFrQixHQUFHRixrQkFBa0IsQ0FBQ2pDLEdBQUcsQ0FBQ1Usc0JBQXNCLENBQUM7RUFDekUsSUFBSXlCLGtCQUFrQixFQUFFO0lBQ3BCLE9BQU9BLGtCQUFrQjtFQUM3QjtFQUNBO0VBQ0E7RUFDQTtFQUNBLE1BQU1DLE9BQU8sR0FBR2pCLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDVixzQkFBc0IsQ0FBQztFQUN2RHVCLGtCQUFrQixDQUFDbUIsR0FBRyxDQUFDMUMsc0JBQXNCLEVBQUUwQixPQUFPLENBQUM7RUFDdkRsRCxNQUFNLENBQUN5RSxJQUFJLENBQUNqRCxzQkFBc0IsQ0FBQyxDQUFDa0QsT0FBTyxDQUFFckIsSUFBSSxJQUFHO0lBQ2hELFFBQU9BLElBQUk7TUFDUDtNQUNBLEtBQUssZ0JBQWdCO01BQ3JCLEtBQUssZUFBZTtNQUNwQixLQUFLLHNCQUFzQjtNQUMzQixLQUFLLFVBQVU7TUFDZixLQUFLLFNBQVM7TUFDZCxLQUFLLGdCQUFnQjtNQUNyQjtNQUNBO01BQ0EsS0FBSyxNQUFNO01BQ1gsS0FBSyxPQUFPO01BQ1osS0FBSyxTQUFTO01BQ2Q7TUFDQTtNQUNBLEtBQUssUUFBUTtNQUNiO01BQ0E7TUFDQSxLQUFLLFFBQVE7TUFDYixLQUFLLFVBQVU7TUFDZixLQUFLLFlBQVk7UUFDYjtVQUNJO1FBQ0o7TUFDSjtRQUNJO1VBQ0lyRCxNQUFNLENBQUNDLGNBQWMsQ0FBQ2lELE9BQU8sRUFBRUcsSUFBSSxFQUFFO1lBQ2pDdkMsR0FBR0EsQ0FBQSxFQUFJO2NBQ0gsTUFBTVksYUFBYSxHQUFHUiw2QkFBNkIsQ0FBQ1Msb0JBQW9CLENBQUNDLFFBQVEsQ0FBQyxDQUFDO2NBQ25GLENBQUMsQ0FBQyxFQUFFWCxpQkFBaUIsQ0FBQzBELCtCQUErQixFQUFFSCxLQUFLLEVBQUU5QyxhQUFhLENBQUM7Y0FDNUUsT0FBT0Ysc0JBQXNCLENBQUM2QixJQUFJLENBQUM7WUFDdkMsQ0FBQztZQUNEYSxHQUFHQSxDQUFFL0QsS0FBSyxFQUFFO2NBQ1JILE1BQU0sQ0FBQ0MsY0FBYyxDQUFDaUQsT0FBTyxFQUFFRyxJQUFJLEVBQUU7Z0JBQ2pDbEQsS0FBSztnQkFDTHlFLFFBQVEsRUFBRSxJQUFJO2dCQUNkL0QsVUFBVSxFQUFFO2NBQ2hCLENBQUMsQ0FBQztZQUNOLENBQUM7WUFDREEsVUFBVSxFQUFFLElBQUk7WUFDaEJnRSxZQUFZLEVBQUU7VUFDbEIsQ0FBQyxDQUFDO1FBQ047SUFDUjtFQUNKLENBQUMsQ0FBQztFQUNGLE9BQU8zQixPQUFPO0FBQ2xCO0FBQ0EsU0FBU0wsdURBQXVEQSxDQUFDckIsc0JBQXNCLEVBQUVnRCxLQUFLLEVBQUU7RUFDNUYsTUFBTXZCLGtCQUFrQixHQUFHRixrQkFBa0IsQ0FBQ2pDLEdBQUcsQ0FBQ1Usc0JBQXNCLENBQUM7RUFDekUsSUFBSXlCLGtCQUFrQixFQUFFO0lBQ3BCLE9BQU9BLGtCQUFrQjtFQUM3QjtFQUNBLE1BQU02QixpQkFBaUIsR0FBRyxJQUFJQyxHQUFHLENBQUMsQ0FBQztFQUNuQyxNQUFNQyxtQkFBbUIsR0FBRyxFQUFFO0VBQzlCO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBLElBQUlDLGtCQUFrQixHQUFHLEtBQUs7RUFDOUIsTUFBTUMsaUJBQWlCLEdBQUcsSUFBSTlCLEtBQUssQ0FBQzVCLHNCQUFzQixFQUFFO0lBQ3hEVixHQUFHQSxDQUFFSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsRUFBRTtNQUN6QixJQUFJLE9BQU9ELElBQUksS0FBSyxRQUFRLElBQUk0QixrQkFBa0IsRUFBRTtRQUNoRCxJQUFJVCxLQUFLLENBQUNMLGtCQUFrQixFQUFFO1VBQzFCLE1BQU1WLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQ3FDLDRCQUE0QixFQUFFLGNBQWMsRUFBRU4sSUFBSSxDQUFDO1VBQ2pGLENBQUMsQ0FBQyxFQUFFL0IsTUFBTSxDQUFDOEMscURBQXFELEVBQUVJLEtBQUssQ0FBQ2pDLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztRQUM5RjtRQUNBLE1BQU0vQixhQUFhLEdBQUdSLDZCQUE2QixDQUFDUyxvQkFBb0IsQ0FBQ0MsUUFBUSxDQUFDLENBQUM7UUFDbkYsQ0FBQyxDQUFDLEVBQUVYLGlCQUFpQixDQUFDMEQsK0JBQStCLEVBQUVILEtBQUssRUFBRTlDLGFBQWEsQ0FBQztNQUNoRjtNQUNBLE9BQU9YLFFBQVEsQ0FBQ3lDLGNBQWMsQ0FBQzFDLEdBQUcsQ0FBQ0osTUFBTSxFQUFFMkMsSUFBSSxFQUFFQyxRQUFRLENBQUM7SUFDOUQsQ0FBQztJQUNEUyxHQUFHQSxDQUFFckQsTUFBTSxFQUFFMkMsSUFBSSxFQUFFO01BQ2YsSUFBSSxPQUFPQSxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCLElBQUltQixLQUFLLENBQUNMLGtCQUFrQixFQUFFO1VBQzFCLE1BQU1WLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQzBDLGlDQUFpQyxFQUFFLGNBQWMsRUFBRVgsSUFBSSxDQUFDO1VBQ3RGLENBQUMsQ0FBQyxFQUFFL0IsTUFBTSxDQUFDOEMscURBQXFELEVBQUVJLEtBQUssQ0FBQ2pDLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztRQUM5RjtNQUNKO01BQ0EsT0FBTzBCLE9BQU8sQ0FBQ3BCLEdBQUcsQ0FBQ3JELE1BQU0sRUFBRTJDLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBQ0RZLE9BQU9BLENBQUV2RCxNQUFNLEVBQUU7TUFDYixJQUFJOEQsS0FBSyxDQUFDTCxrQkFBa0IsRUFBRTtRQUMxQixNQUFNVixVQUFVLEdBQUcsOERBQThEO1FBQ2pGLENBQUMsQ0FBQyxFQUFFbkMsTUFBTSxDQUFDOEMscURBQXFELEVBQUVJLEtBQUssQ0FBQ2pDLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztNQUM5RjtNQUNBLE9BQU8wQixPQUFPLENBQUNsQixPQUFPLENBQUN2RCxNQUFNLENBQUM7SUFDbEM7RUFDSixDQUFDLENBQUM7RUFDRjtFQUNBO0VBQ0E7RUFDQSxNQUFNd0MsT0FBTyxHQUFHLElBQUlqQixPQUFPLENBQUVDLE9BQU8sSUFBRyxDQUFDLENBQUMsRUFBRVgsVUFBVSxDQUFDNkQsaUJBQWlCLEVBQUUsTUFBSWxELE9BQU8sQ0FBQ1Ysc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0VBQzlHMEIsT0FBTyxDQUFDbUMsSUFBSSxDQUFDLE1BQUk7SUFDYkosa0JBQWtCLEdBQUcsSUFBSTtFQUM3QixDQUFDLENBQUM7RUFDRmpGLE1BQU0sQ0FBQ3lFLElBQUksQ0FBQ2pELHNCQUFzQixDQUFDLENBQUNrRCxPQUFPLENBQUVyQixJQUFJLElBQUc7SUFDaEQsSUFBSS9CLE1BQU0sQ0FBQ2dFLG1CQUFtQixDQUFDdkIsR0FBRyxDQUFDVixJQUFJLENBQUMsRUFBRTtNQUN0QztNQUNBO01BQ0EyQixtQkFBbUIsQ0FBQ08sSUFBSSxDQUFDbEMsSUFBSSxDQUFDO0lBQ2xDLENBQUMsTUFBTTtNQUNIeUIsaUJBQWlCLENBQUNVLEdBQUcsQ0FBQ25DLElBQUksQ0FBQztNQUMzQnJELE1BQU0sQ0FBQ0MsY0FBYyxDQUFDaUQsT0FBTyxFQUFFRyxJQUFJLEVBQUU7UUFDakN2QyxHQUFHQSxDQUFBLEVBQUk7VUFDSCxPQUFPb0UsaUJBQWlCLENBQUM3QixJQUFJLENBQUM7UUFDbEMsQ0FBQztRQUNEYSxHQUFHQSxDQUFFdUIsUUFBUSxFQUFFO1VBQ1h6RixNQUFNLENBQUNDLGNBQWMsQ0FBQ2lELE9BQU8sRUFBRUcsSUFBSSxFQUFFO1lBQ2pDbEQsS0FBSyxFQUFFc0YsUUFBUTtZQUNmYixRQUFRLEVBQUUsSUFBSTtZQUNkL0QsVUFBVSxFQUFFO1VBQ2hCLENBQUMsQ0FBQztRQUNOLENBQUM7UUFDREEsVUFBVSxFQUFFLElBQUk7UUFDaEJnRSxZQUFZLEVBQUU7TUFDbEIsQ0FBQyxDQUFDO0lBQ047RUFDSixDQUFDLENBQUM7RUFDRixNQUFNMUIsY0FBYyxHQUFHLElBQUlDLEtBQUssQ0FBQ0YsT0FBTyxFQUFFO0lBQ3RDcEMsR0FBR0EsQ0FBRUosTUFBTSxFQUFFMkMsSUFBSSxFQUFFQyxRQUFRLEVBQUU7TUFDekIsSUFBSUQsSUFBSSxLQUFLLE1BQU0sSUFBSW1CLEtBQUssQ0FBQ0wsa0JBQWtCLEVBQUU7UUFDN0MsTUFBTVYsVUFBVSxHQUFHLHFCQUFxQjtRQUN4QyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQzhDLHFEQUFxRCxFQUFFSSxLQUFLLENBQUNqQyxLQUFLLEVBQUVrQixVQUFVLENBQUM7TUFDOUY7TUFDQSxJQUFJLE9BQU9KLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDMUIsSUFBSSxDQUFDL0IsTUFBTSxDQUFDZ0UsbUJBQW1CLENBQUN2QixHQUFHLENBQUNWLElBQUksQ0FBQyxLQUFLeUIsaUJBQWlCLENBQUNmLEdBQUcsQ0FBQ1YsSUFBSSxDQUFDO1FBQUk7UUFDN0U7UUFDQThCLE9BQU8sQ0FBQ3BCLEdBQUcsQ0FBQ3JELE1BQU0sRUFBRTJDLElBQUksQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO1VBQ2xDLE1BQU1JLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRW5DLE1BQU0sQ0FBQ3FDLDRCQUE0QixFQUFFLGNBQWMsRUFBRU4sSUFBSSxDQUFDO1VBQ2pGcUMsU0FBUyxDQUFDbEIsS0FBSyxDQUFDakMsS0FBSyxFQUFFa0IsVUFBVSxDQUFDO1FBQ3RDO01BQ0o7TUFDQSxPQUFPMUMsUUFBUSxDQUFDeUMsY0FBYyxDQUFDMUMsR0FBRyxDQUFDSixNQUFNLEVBQUUyQyxJQUFJLEVBQUVDLFFBQVEsQ0FBQztJQUM5RCxDQUFDO0lBQ0RZLEdBQUdBLENBQUV4RCxNQUFNLEVBQUUyQyxJQUFJLEVBQUVsRCxLQUFLLEVBQUVtRCxRQUFRLEVBQUU7TUFDaEMsSUFBSSxPQUFPRCxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCeUIsaUJBQWlCLENBQUNhLE1BQU0sQ0FBQ3RDLElBQUksQ0FBQztNQUNsQztNQUNBLE9BQU84QixPQUFPLENBQUNqQixHQUFHLENBQUN4RCxNQUFNLEVBQUUyQyxJQUFJLEVBQUVsRCxLQUFLLEVBQUVtRCxRQUFRLENBQUM7SUFDckQsQ0FBQztJQUNEUyxHQUFHQSxDQUFFckQsTUFBTSxFQUFFMkMsSUFBSSxFQUFFO01BQ2YsSUFBSSxPQUFPQSxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzFCLElBQUksQ0FBQy9CLE1BQU0sQ0FBQ2dFLG1CQUFtQixDQUFDdkIsR0FBRyxDQUFDVixJQUFJLENBQUMsS0FBS3lCLGlCQUFpQixDQUFDZixHQUFHLENBQUNWLElBQUksQ0FBQztRQUFJO1FBQzdFO1FBQ0E4QixPQUFPLENBQUNwQixHQUFHLENBQUNyRCxNQUFNLEVBQUUyQyxJQUFJLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtVQUNsQyxNQUFNSSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUVuQyxNQUFNLENBQUMwQyxpQ0FBaUMsRUFBRSxjQUFjLEVBQUVYLElBQUksQ0FBQztVQUN0RnFDLFNBQVMsQ0FBQ2xCLEtBQUssQ0FBQ2pDLEtBQUssRUFBRWtCLFVBQVUsQ0FBQztRQUN0QztNQUNKO01BQ0EsT0FBTzBCLE9BQU8sQ0FBQ3BCLEdBQUcsQ0FBQ3JELE1BQU0sRUFBRTJDLElBQUksQ0FBQztJQUNwQyxDQUFDO0lBQ0RZLE9BQU9BLENBQUV2RCxNQUFNLEVBQUU7TUFDYixNQUFNK0MsVUFBVSxHQUFHLHdDQUF3QztNQUMzRGlDLFNBQVMsQ0FBQ2xCLEtBQUssQ0FBQ2pDLEtBQUssRUFBRWtCLFVBQVUsRUFBRXVCLG1CQUFtQixDQUFDO01BQ3ZELE9BQU9HLE9BQU8sQ0FBQ2xCLE9BQU8sQ0FBQ3ZELE1BQU0sQ0FBQztJQUNsQztFQUNKLENBQUMsQ0FBQztFQUNGcUMsa0JBQWtCLENBQUNtQixHQUFHLENBQUMxQyxzQkFBc0IsRUFBRTJCLGNBQWMsQ0FBQztFQUM5RCxPQUFPQSxjQUFjO0FBQ3pCO0FBQ0EsU0FBU3VDLFNBQVNBLENBQUNuRCxLQUFLLEVBQUVrQixVQUFVLEVBQUVtQyxpQkFBaUIsRUFBRTtFQUNyRDtFQUNBLElBQUlBLGlCQUFpQixJQUFJQSxpQkFBaUIsQ0FBQ0MsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUNuREMsNEJBQTRCLENBQUN2RCxLQUFLLEVBQUVrQixVQUFVLEVBQUVtQyxpQkFBaUIsQ0FBQztFQUN0RSxDQUFDLE1BQU07SUFDSEcsaUJBQWlCLENBQUN4RCxLQUFLLEVBQUVrQixVQUFVLENBQUM7RUFDeEM7RUFDQSxNQUFNL0IsYUFBYSxHQUFHUiw2QkFBNkIsQ0FBQ1Msb0JBQW9CLENBQUNDLFFBQVEsQ0FBQyxDQUFDO0VBQ25GLElBQUlGLGFBQWEsSUFBSUEsYUFBYSxDQUFDRyxJQUFJLEtBQUssU0FBUyxJQUFJSCxhQUFhLENBQUNzRSxjQUFjLEtBQUssSUFBSSxFQUFFO0lBQzVGO0lBQ0E7SUFDQSxNQUFNQyxZQUFZLEdBQUd2RSxhQUFhO0lBQ2xDLENBQUMsQ0FBQyxFQUFFVCxpQkFBaUIsQ0FBQ2lGLHNDQUFzQyxFQUFFRCxZQUFZLENBQUM7RUFDL0U7QUFDSjtBQUNBLE1BQU1FLElBQUksR0FBR0EsQ0FBQSxLQUFJLENBQUMsQ0FBQztBQUNuQixNQUFNSixpQkFBaUIsR0FBR3RELE1BQW9ELEdBQUcwRCxDQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUU5RSx5Q0FBeUMsQ0FBQ2dGLDJDQUEyQyxFQUFFeEMsdUJBQXVCLENBQUM7QUFDM00sTUFBTWlDLDRCQUE0QixHQUFHckQsTUFBb0QsR0FBRzBELENBQUksR0FBRyxDQUFDLENBQUMsRUFBRTlFLHlDQUF5QyxDQUFDZ0YsMkNBQTJDLEVBQUVDLGdDQUFnQyxDQUFDO0FBQy9OLFNBQVN6Qyx1QkFBdUJBLENBQUN0QixLQUFLLEVBQUVrQixVQUFVLEVBQUU7RUFDaEQsTUFBTThDLE1BQU0sR0FBR2hFLEtBQUssR0FBSSxVQUFTQSxLQUFNLElBQUcsR0FBRyxhQUFhO0VBQzFELE9BQU8sSUFBSWlFLEtBQUssQ0FBRSxHQUFFRCxNQUFPLFFBQU85QyxVQUFXLElBQUcsR0FBSSxrRUFBaUUsR0FBSSxnRUFBK0QsQ0FBQztBQUM3TDtBQUNBLFNBQVM2QyxnQ0FBZ0NBLENBQUMvRCxLQUFLLEVBQUVrQixVQUFVLEVBQUVtQyxpQkFBaUIsRUFBRTtFQUM1RSxNQUFNVyxNQUFNLEdBQUdoRSxLQUFLLEdBQUksVUFBU0EsS0FBTSxJQUFHLEdBQUcsYUFBYTtFQUMxRCxPQUFPLElBQUlpRSxLQUFLLENBQUUsR0FBRUQsTUFBTyxRQUFPOUMsVUFBVyxJQUFHLEdBQUksa0VBQWlFLEdBQUksa0VBQWlFLEdBQUksbUVBQWtFLEdBQUksR0FBRWdELDJCQUEyQixDQUFDYixpQkFBaUIsQ0FBRSxJQUFHLEdBQUksZ0VBQStELENBQUM7QUFDaFk7QUFDQSxTQUFTYSwyQkFBMkJBLENBQUNDLFVBQVUsRUFBRTtFQUM3QyxRQUFPQSxVQUFVLENBQUNiLE1BQU07SUFDcEIsS0FBSyxDQUFDO01BQ0YsTUFBTSxJQUFJMUUsZUFBZSxDQUFDd0YsY0FBYyxDQUFDLHFGQUFxRixDQUFDO0lBQ25JLEtBQUssQ0FBQztNQUNGLE9BQVEsS0FBSUQsVUFBVSxDQUFDLENBQUMsQ0FBRSxJQUFHO0lBQ2pDLEtBQUssQ0FBQztNQUNGLE9BQVEsS0FBSUEsVUFBVSxDQUFDLENBQUMsQ0FBRSxZQUFXQSxVQUFVLENBQUMsQ0FBQyxDQUFFLElBQUc7SUFDMUQ7TUFDSTtRQUNJLElBQUlFLFdBQVcsR0FBRyxFQUFFO1FBQ3BCLEtBQUksSUFBSUMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHSCxVQUFVLENBQUNiLE1BQU0sR0FBRyxDQUFDLEVBQUVnQixDQUFDLEVBQUUsRUFBQztVQUMxQ0QsV0FBVyxJQUFLLEtBQUlGLFVBQVUsQ0FBQ0csQ0FBQyxDQUFFLE1BQUs7UUFDM0M7UUFDQUQsV0FBVyxJQUFLLFdBQVVGLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDYixNQUFNLEdBQUcsQ0FBQyxDQUFFLElBQUc7UUFDL0QsT0FBT2UsV0FBVztNQUN0QjtFQUNSO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZTogbnVsbCxcbiAgICBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50OiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2U6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXNGb3JDbGllbnRQYWdlO1xuICAgIH0sXG4gICAgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGE7XG4gICAgfSxcbiAgICBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2U7XG4gICAgfVxufSk7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5nID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmdcIik7XG5jb25zdCBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsXCIpO1xuY29uc3QgX2ludmFyaWFudGVycm9yID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yXCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmd1dGlscyA9IHJlcXVpcmUoXCIuLi9keW5hbWljLXJlbmRlcmluZy11dGlsc1wiKTtcbmNvbnN0IF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXJcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IF9zY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vLi4vbGliL3NjaGVkdWxlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKTtcbn1cbmNvbnN0IGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhID0gY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yU2VydmVyUGFnZTtcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2Uod29ya1N0b3JlKSB7XG4gICAgaWYgKHdvcmtTdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAgIC8vIGRpY3Rpb25hcnkgb2JqZWN0LlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAvLyBkeW5hbWljSU8gUHJlcmVuZGVyXG4gICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyBpbiBhIG1vZGUgdGhhdCBhYm9ydHMgKGR5bmFtaWNJTykgYW5kIHNob3VsZCBzdGFsbFxuICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byBlbnN1cmUgdGhlIFJTQyBzaWRlIGlzIGNvbnNpZGVyZWQgZHluYW1pY1xuICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgc2VhcmNoUGFyYW1zYCcpO1xuICAgIH1cbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnRzLiBXZSByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGhvdXRcbiAgICAvLyBhbnkgdHJhY2tpbmcgYmVjYXVzZSB3ZSdyZSBqdXN0IHRyYW5zcG9ydGluZyBhIHZhbHVlIGZyb20gc2VydmVyIHRvIGNsaWVudCB3aGVyZSB0aGUgdHJhY2tpbmdcbiAgICAvLyB3aWxsIGJlIGFwcGxpZWQuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMod29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICByZXR1cm4gbWFrZUFib3J0aW5nRXhvdGljU2VhcmNoUGFyYW1zKHdvcmtTdG9yZS5yb3V0ZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIGNhc2VzIGFyZSBwcmVyZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgLy8gV2UgYXJlIGluIGEgbGVnYWN5IHN0YXRpYyBnZW5lcmF0aW9uIGFuZCBuZWVkIHRvIGludGVycnVwdCB0aGUgcHJlcmVuZGVyXG4gICAgLy8gd2hlbiBzZWFyY2ggcGFyYW1zIGFyZSBhY2Nlc3NlZC5cbiAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSkge1xuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB3b3JrU3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkU2VhcmNoUGFyYW1zID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1ha2VBYm9ydGluZ0V4b3RpY1NlYXJjaFBhcmFtcyhyb3V0ZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHByZXJlbmRlclN0b3JlKTtcbiAgICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSAoMCwgX2R5bmFtaWNyZW5kZXJpbmd1dGlscy5tYWtlSGFuZ2luZ1Byb21pc2UpKHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCwgJ2BzZWFyY2hQYXJhbXNgJyk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgaXQgaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gocHJvcCl7XG4gICAgICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFubm90YXRlRHluYW1pY0FjY2VzcykoZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHVzZShzZWFyY2hQYXJhbXMpYCwgYHNlYXJjaFBhcmFtcy5zdGF0dXNgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hbm5vdGF0ZUR5bmFtaWNBY2Nlc3MpKGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPYmplY3QgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgY2FzZSAnaGFzT3duUHJvcGVydHknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2lzUHJvdG90eXBlT2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b1N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWVPZic6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9Mb2NhbGVTdHJpbmcnOlxuICAgICAgICAgICAgICAgIC8vIFByb21pc2UgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdjYXRjaCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmluYWxseSc6XG4gICAgICAgICAgICAgICAgLy8gQ29tbW9uIHRlc3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICd0b0pTT04nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyQkdHlwZW9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICdfX2VzTW9kdWxlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBrZXkgY2hlY2tpbmcgdG8gYmUgdXNlZCBleGNlcHQgZm9yIHRlc3RpbmcgdGhlIGV4aXN0ZW5jZSBvZlxuICAgICAgICAgICAgLy8gc2VhcmNoUGFyYW1zIHNvIHdlIG1ha2UgYWxsIGhhcyB0ZXN0cyB0cmlnZ2VyIGR5bmFtaWMuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MpKHJvdXRlLCBleHByZXNzaW9uLCBlcnJvciwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MpKHJvdXRlLCBleHByZXNzaW9uLCBlcnJvciwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldChwcmVyZW5kZXJTdG9yZSwgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyh3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh3b3JrU3RvcmUpO1xuICAgIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgdW5kZXJseWluZ1NlYXJjaFBhcmFtcyA9IHt9O1xuICAgIC8vIEZvciBzZWFyY2ggcGFyYW1zIHdlIGRvbid0IGNvbnN0cnVjdCBhIFJlYWN0UHJvbWlzZSBiZWNhdXNlIHdlIHdhbnQgdG8gaW50ZXJydXB0XG4gICAgLy8gcmVuZGVyaW5nIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCB3YXMgbm90IHNldCBmcm9tIG91dHNpZGUgYW5kIHNvIHdlIG9ubHkgd2FudFxuICAgIC8vIHRvIGhhdmUgcHJvcGVydGllcyBsaWtlIHZhbHVlIGFuZCBzdGF0dXMgaWYgUmVhY3Qgc2V0cyB0aGVtLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgaXQgaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gocHJvcCl7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hhc093blByb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpc1Byb3RvdHlwZU9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eUlzRW51bWVyYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9TdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlT2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvTG9jYWxlU3RyaW5nJzpcbiAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnY2F0Y2gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsbHknOlxuICAgICAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAndG9KU09OJzpcbiAgICAgICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnX19lc01vZHVsZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhdHVzJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgdXNlKHNlYXJjaFBhcmFtcylgLCBgc2VhcmNoUGFyYW1zLnN0YXR1c2AsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBrZXkgY2hlY2tpbmcgdG8gYmUgdXNlZCBleGNlcHQgZm9yIHRlc3RpbmcgdGhlIGV4aXN0ZW5jZSBvZlxuICAgICAgICAgICAgLy8gc2VhcmNoUGFyYW1zIHNvIHdlIG1ha2UgYWxsIGhhcyB0ZXN0cyB0cmlnZ2VyIGR5bmFtaWMuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQod29ya1N0b3JlLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBzZWFyY2hQYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgc3dpdGNoKHByb3Ape1xuICAgICAgICAgICAgLy8gT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgY2FzZSAnaGFzT3duUHJvcGVydHknOlxuICAgICAgICAgICAgY2FzZSAnaXNQcm90b3R5cGVPZic6XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eUlzRW51bWVyYWJsZSc6XG4gICAgICAgICAgICBjYXNlICd0b1N0cmluZyc6XG4gICAgICAgICAgICBjYXNlICd2YWx1ZU9mJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvTG9jYWxlU3RyaW5nJzpcbiAgICAgICAgICAgIC8vIFByb21pc2UgcHJvdG90eXBlXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICBjYXNlICdjYXRjaCc6XG4gICAgICAgICAgICBjYXNlICdmaW5hbGx5JzpcbiAgICAgICAgICAgIC8vIFJlYWN0IFByb21pc2UgZXh0ZW5zaW9uXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc3RhdHVzJzpcbiAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3RvSlNPTic6XG4gICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICBjYXNlICdfX2VzTW9kdWxlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcikoc3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzID0gW107XG4gICAgLy8gV2UgaGF2ZSBhbiB1bmZvcnR1bmF0ZSBzZXF1ZW5jZSBvZiBldmVudHMgdGhhdCByZXF1aXJlcyB0aGlzIGluaXRpYWxpemF0aW9uIGxvZ2ljLiBXZSB3YW50IHRvIGluc3RydW1lbnQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBzZWFyY2hQYXJhbXMgb2JqZWN0IHRvIGRldGVjdCBpZiB5b3UgYXJlIGFjY2Vzc2luZyB2YWx1ZXMgaW4gZGV2LiBUaGlzIGlzIHVzZWQgZm9yIHdhcm5pbmdzIGFuZCBmb3IgdGhpbmdzIGxpa2UgdGhlIHN0YXRpYyBwcmVyZW5kZXJcbiAgICAvLyBpbmRpY2F0b3IuIEhvd2V2ZXIgd2hlbiB3ZSBwYXNzIHRoaXMgcHJveHkgdG8gb3VyIFByb21pc2UucmVzb2x2ZSgpIGJlbG93IHRoZSBWTSBjaGVja3MgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGEgcHJvbWlzZSBieSBsb29raW5nXG4gICAgLy8gYXQgdGhlIGAudGhlbmAgcHJvcGVydHkuIFRvIG91ciBkeW5hbWljIHRyYWNraW5nIGxvZ2ljIHRoaXMgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBhIGB0aGVuYCBzZWFyY2hQYXJhbSBhbmQgc28gd2Ugd291bGQgbm9ybWFsbHkgdHJpZ2dlclxuICAgIC8vIGR5bmFtaWMgdHJhY2tpbmcuIEhvd2V2ZXIgd2Uga25vdyB0aGF0IHRoaXMgLnRoZW4gaXMgbm90IHJlYWwgZHluYW1pYyBhY2Nlc3MsIGl0J3MganVzdCBob3cgdGhlbmFibGVzIHJlc29sdmUgaW4gc2VxdWVuY2UuIFNvIHdlIGludHJvZHVjZVxuICAgIC8vIHRoaXMgaW5pdGlhbGl6YXRpb24gY29uY2VwdCBzbyB3ZSBvbWl0IHRoZSBkeW5hbWljIGNoZWNrIHVudGlsIGFmdGVyIHdlJ3ZlIGNvbnN0cnVjdGVkIG91ciByZXNvbHZlZCBwcm9taXNlLlxuICAgIGxldCBwcm9taXNlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwcm94aWVkVW5kZXJseWluZyA9IG5ldyBQcm94eSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB7XG4gICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBwcm9taXNlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcikoc3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKShzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKShzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBzZWFyY2hQYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT4oMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcykpKTtcbiAgICBwcm9taXNlLnRoZW4oKCk9PntcbiAgICAgICAgcHJvbWlzZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgICAgICAgdW5wcm94aWVkUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZFVuZGVybHlpbmdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0aGVuJyAmJiBzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BzZWFyY2hQYXJhbXMudGhlbmAnO1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMudGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IpKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJiAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8IC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiYgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fCAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgT2JqZWN0LmtleXMoc2VhcmNoUGFyYW1zKWAgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcykge1xuICAgIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gICAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzICYmIG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcgJiYgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAgICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgICAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSB3b3JrVW5pdFN0b3JlO1xuICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYpKHJlcXVlc3RTdG9yZSk7XG4gICAgfVxufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiAoMCwgX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIuY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldikoY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3IpO1xuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogKDAsIF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyLmNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYpKGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICc7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICsgYFxcYHNlYXJjaFBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdlcmUgbm90IGF2YWlsYWJsZSB0aHJvdWdoIGVudW1lcmF0aW9uIGAgKyBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBvciB3ZWxsLWtub3duIHByb3BlcnR5IG5hbWVzOiBgICsgYCR7ZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKG1pc3NpbmdQcm9wZXJ0aWVzKX0uIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKSB7XG4gICAgc3dpdGNoKHByb3BlcnRpZXMubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhyb3cgbmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXNGb3JDbGllbnRQYWdlIiwiY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhIiwiY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yU2VydmVyUGFnZSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9yZWZsZWN0IiwicmVxdWlyZSIsIl9keW5hbWljcmVuZGVyaW5nIiwiX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJfaW52YXJpYW50ZXJyb3IiLCJfZHluYW1pY3JlbmRlcmluZ3V0aWxzIiwiX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIiLCJfdXRpbHMiLCJfc2NoZWR1bGVyIiwidW5kZXJseWluZ1NlYXJjaFBhcmFtcyIsIndvcmtTdG9yZSIsIndvcmtVbml0U3RvcmUiLCJ3b3JrVW5pdEFzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwidHlwZSIsImNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtcyIsImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtcyIsImZvcmNlU3RhdGljIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVyZW5kZXJTdG9yZSIsIm1ha2VIYW5naW5nUHJvbWlzZSIsInJlbmRlclNpZ25hbCIsIm1ha2VBYm9ydGluZ0V4b3RpY1NlYXJjaFBhcmFtcyIsInJvdXRlIiwibWFrZUVycm9yaW5nRXhvdGljU2VhcmNoUGFyYW1zIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyIsIkNhY2hlZFNlYXJjaFBhcmFtcyIsIldlYWtNYXAiLCJjYWNoZWRTZWFyY2hQYXJhbXMiLCJwcm9taXNlIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInByb3AiLCJyZWNlaXZlciIsImhhc093biIsIlJlZmxlY3RBZGFwdGVyIiwiZXhwcmVzc2lvbiIsImFubm90YXRlRHluYW1pY0FjY2VzcyIsImRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MiLCJlcnJvciIsImNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yIiwiYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyIsImhhcyIsImRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSIsIm93bktleXMiLCJzZXQiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvciIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwiZHluYW1pY1RyYWNraW5nIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJzdG9yZSIsImtleXMiLCJmb3JFYWNoIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwicHJveGllZFByb3BlcnRpZXMiLCJTZXQiLCJ1bnByb3hpZWRQcm9wZXJ0aWVzIiwicHJvbWlzZUluaXRpYWxpemVkIiwicHJveGllZFVuZGVybHlpbmciLCJSZWZsZWN0Iiwic2NoZWR1bGVJbW1lZGlhdGUiLCJ0aGVuIiwid2VsbEtub3duUHJvcGVydGllcyIsInB1c2giLCJhZGQiLCJuZXdWYWx1ZSIsInN5bmNJT0RldiIsImRlbGV0ZSIsIm1pc3NpbmdQcm9wZXJ0aWVzIiwibGVuZ3RoIiwid2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiIsIndhcm5Gb3JTeW5jQWNjZXNzIiwicHJlcmVuZGVyUGhhc2UiLCJyZXF1ZXN0U3RvcmUiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsIm5vb3AiLCJfX05FWFRfRElTQUJMRV9TWU5DX0RZTkFNSUNfQVBJX1dBUk5JTkdTIiwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiIsImNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yIiwicHJlZml4IiwiRXJyb3IiLCJkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0aWVzIiwiSW52YXJpYW50RXJyb3IiLCJkZXNjcmlwdGlvbiIsImkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/server/request/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  describeHasCheckingStringProperty: function () {\n    return describeHasCheckingStringProperty;\n  },\n  describeStringPropertyAccess: function () {\n    return describeStringPropertyAccess;\n  },\n  isRequestAPICallableInsideAfter: function () {\n    return isRequestAPICallableInsideAfter;\n  },\n  throwWithStaticGenerationBailoutError: function () {\n    return throwWithStaticGenerationBailoutError;\n  },\n  throwWithStaticGenerationBailoutErrorWithDynamicError: function () {\n    return throwWithStaticGenerationBailoutErrorWithDynamicError;\n  },\n  wellKnownProperties: function () {\n    return wellKnownProperties;\n  }\n});\nconst _staticgenerationbailout = __webpack_require__(/*! ../../client/components/static-generation-bailout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/static-generation-bailout.js\");\nconst _aftertaskasyncstorageexternal = __webpack_require__(/*! ../app-render/after-task-async-storage.external */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/after-task-async-storage.external.js\");\n// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `ಠ_ಠ` is a valid identifier it's ok to print `searchParams['ಠ_ಠ']`\n// even if this would have been fine too `searchParams.ಠ_ಠ`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nfunction describeStringPropertyAccess(target, prop) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``;\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``;\n}\nfunction describeHasCheckingStringProperty(target, prop) {\n  const stringifiedProp = JSON.stringify(prop);\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`;\n}\nfunction throwWithStaticGenerationBailoutError(route, expression) {\n  throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n}\nfunction throwWithStaticGenerationBailoutErrorWithDynamicError(route, expression) {\n  throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n}\nfunction isRequestAPICallableInsideAfter() {\n  const afterTaskStore = _aftertaskasyncstorageexternal.afterTaskAsyncStorage.getStore();\n  return (afterTaskStore == null ? void 0 : afterTaskStore.rootTaskSpawnPhase) === 'action';\n}\nconst wellKnownProperties = new Set(['hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toString', 'valueOf', 'toLocaleString',\n// Promise prototype\n// fallthrough\n'then', 'catch', 'finally',\n// React Promise extension\n// fallthrough\n'status',\n// React introspection\n'displayName',\n// Common tested properties\n// fallthrough\n'toJSON', '$$typeof', '__esModule']);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztFQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsQ0FBQyxLQUFLQyxDQU9MLENBQUM7QUFDRixTQUFTTyxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLEdBQUcsRUFBRTtFQUMxQixLQUFJLElBQUlDLElBQUksSUFBSUQsR0FBRyxFQUFDYixNQUFNLENBQUNDLGNBQWMsQ0FBQ1csTUFBTSxFQUFFRSxJQUFJLEVBQUU7SUFDcERDLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDTjtBQUNBSCxPQUFPLENBQUNULE9BQU8sRUFBRTtFQUNiRyxpQ0FBaUMsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDMUMsT0FBT0EsaUNBQWlDO0VBQzVDLENBQUM7RUFDREMsNEJBQTRCLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ3JDLE9BQU9BLDRCQUE0QjtFQUN2QyxDQUFDO0VBQ0RDLCtCQUErQixFQUFFLFNBQUFBLENBQUEsRUFBVztJQUN4QyxPQUFPQSwrQkFBK0I7RUFDMUMsQ0FBQztFQUNEQyxxQ0FBcUMsRUFBRSxTQUFBQSxDQUFBLEVBQVc7SUFDOUMsT0FBT0EscUNBQXFDO0VBQ2hELENBQUM7RUFDREMscURBQXFELEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQzlELE9BQU9BLHFEQUFxRDtFQUNoRSxDQUFDO0VBQ0RDLG1CQUFtQixFQUFFLFNBQUFBLENBQUEsRUFBVztJQUM1QixPQUFPQSxtQkFBbUI7RUFDOUI7QUFDSixDQUFDLENBQUM7QUFDRixNQUFNTyx3QkFBd0IsR0FBR0MsbUJBQU8sQ0FBQyxzSkFBbUQsQ0FBQztBQUM3RixNQUFNQyw4QkFBOEIsR0FBR0QsbUJBQU8sQ0FBQyw0SkFBaUQsQ0FBQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUUsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ2pFLFNBQVNkLDRCQUE0QkEsQ0FBQ00sTUFBTSxFQUFFUyxJQUFJLEVBQUU7RUFDaEQsSUFBSUQsNEJBQTRCLENBQUNFLElBQUksQ0FBQ0QsSUFBSSxDQUFDLEVBQUU7SUFDekMsT0FBUSxLQUFJVCxNQUFPLElBQUdTLElBQUssSUFBRztFQUNsQztFQUNBLE9BQVEsS0FBSVQsTUFBTyxJQUFHVyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0gsSUFBSSxDQUFFLEtBQUk7QUFDbkQ7QUFDQSxTQUFTaEIsaUNBQWlDQSxDQUFDTyxNQUFNLEVBQUVTLElBQUksRUFBRTtFQUNyRCxNQUFNSSxlQUFlLEdBQUdGLElBQUksQ0FBQ0MsU0FBUyxDQUFDSCxJQUFJLENBQUM7RUFDNUMsT0FBUSxpQkFBZ0JULE1BQU8sS0FBSWEsZUFBZ0IsVUFBU0EsZUFBZ0IsT0FBTWIsTUFBTyxnQkFBZTtBQUM1RztBQUNBLFNBQVNKLHFDQUFxQ0EsQ0FBQ2tCLEtBQUssRUFBRUMsVUFBVSxFQUFFO0VBQzlELE1BQU0sSUFBSVYsd0JBQXdCLENBQUNXLHFCQUFxQixDQUFFLFNBQVFGLEtBQU0sb0RBQW1EQyxVQUFXLDRIQUEySCxDQUFDO0FBQ3RRO0FBQ0EsU0FBU2xCLHFEQUFxREEsQ0FBQ2lCLEtBQUssRUFBRUMsVUFBVSxFQUFFO0VBQzlFLE1BQU0sSUFBSVYsd0JBQXdCLENBQUNXLHFCQUFxQixDQUFFLFNBQVFGLEtBQU0sK0VBQThFQyxVQUFXLDRIQUEySCxDQUFDO0FBQ2pTO0FBQ0EsU0FBU3BCLCtCQUErQkEsQ0FBQSxFQUFHO0VBQ3ZDLE1BQU1zQixjQUFjLEdBQUdWLDhCQUE4QixDQUFDVyxxQkFBcUIsQ0FBQ0MsUUFBUSxDQUFDLENBQUM7RUFDdEYsT0FBTyxDQUFDRixjQUFjLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxHQUFHQSxjQUFjLENBQUNHLGtCQUFrQixNQUFNLFFBQVE7QUFDN0Y7QUFDQSxNQUFNdEIsbUJBQW1CLEdBQUcsSUFBSXVCLEdBQUcsQ0FBQyxDQUNoQyxnQkFBZ0IsRUFDaEIsZUFBZSxFQUNmLHNCQUFzQixFQUN0QixVQUFVLEVBQ1YsU0FBUyxFQUNULGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsTUFBTSxFQUNOLE9BQU8sRUFDUCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsUUFBUSxFQUNSLFVBQVUsRUFDVixZQUFZLENBQ2YsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0L3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5OiBudWxsLFxuICAgIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3M6IG51bGwsXG4gICAgaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcjogbnVsbCxcbiAgICB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yOiBudWxsLFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yOiBudWxsLFxuICAgIHdlbGxLbm93blByb3BlcnRpZXM6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eTtcbiAgICB9LFxuICAgIGRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcztcbiAgICB9LFxuICAgIGlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcjtcbiAgICB9LFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcjtcbiAgICB9LFxuICAgIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yO1xuICAgIH0sXG4gICAgd2VsbEtub3duUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3ZWxsS25vd25Qcm9wZXJ0aWVzO1xuICAgIH1cbn0pO1xuY29uc3QgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9jb21wb25lbnRzL3N0YXRpYy1nZW5lcmF0aW9uLWJhaWxvdXRcIik7XG5jb25zdCBfYWZ0ZXJ0YXNrYXN5bmNzdG9yYWdlZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9hZnRlci10YXNrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG4vLyBUaGlzIHJlZ2V4IHdpbGwgaGF2ZSBmYXN0IG5lZ2F0aXZlcyBtZWFuaW5nIHZhbGlkIGlkZW50aWZpZXJzIG1heSBub3QgcGFzc1xuLy8gdGhpcyB0ZXN0LiBIb3dldmVyIHRoaXMgaXMgb25seSB1c2VkIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiB0byBwcm92aWRlIGhpbnRzXG4vLyBhYm91dCB3aHkgYSBwYWdlIGJhaWxlZCBvdXQgb2Ygc29tZSBvciBhbGwgcHJlcmVuZGVyaW5nIGFuZCB3ZSBjYW4gdXNlIGJyYWNrZXQgbm90YXRpb25cbi8vIGZvciBleGFtcGxlIHdoaWxlIGDgsqBf4LKgYCBpcyBhIHZhbGlkIGlkZW50aWZpZXIgaXQncyBvayB0byBwcmludCBgc2VhcmNoUGFyYW1zWyfgsqBf4LKgJ11gXG4vLyBldmVuIGlmIHRoaXMgd291bGQgaGF2ZSBiZWVuIGZpbmUgdG9vIGBzZWFyY2hQYXJhbXMu4LKgX+CyoGBcbmNvbnN0IGlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIgPSAvXltBLVphLXpfJF1bQS1aYS16MC05XyRdKiQvO1xuZnVuY3Rpb24gZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2Vzcyh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoaXNEZWZpbml0ZWx5QVZhbGlkSWRlbnRpZmllci50ZXN0KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBgXFxgJHt0YXJnZXR9LiR7cHJvcH1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gYFxcYCR7dGFyZ2V0fVske0pTT04uc3RyaW5naWZ5KHByb3ApfV1cXGBgO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkUHJvcCA9IEpTT04uc3RyaW5naWZ5KHByb3ApO1xuICAgIHJldHVybiBgXFxgUmVmbGVjdC5oYXMoJHt0YXJnZXR9LCAke3N0cmluZ2lmaWVkUHJvcH0pXFxgLCBcXGAke3N0cmluZ2lmaWVkUHJvcH0gaW4gJHt0YXJnZXR9XFxgLCBvciBzaW1pbGFyYDtcbn1cbmZ1bmN0aW9uIHRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3Iocm91dGUsIGV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0LlN0YXRpY0dlbkJhaWxvdXRFcnJvcihgUm91dGUgJHtyb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYCk7XG59XG5mdW5jdGlvbiB0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbikge1xuICAgIHRocm93IG5ldyBfc3RhdGljZ2VuZXJhdGlvbmJhaWxvdXQuU3RhdGljR2VuQmFpbG91dEVycm9yKGBSb3V0ZSAke3JvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYCk7XG59XG5mdW5jdGlvbiBpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyKCkge1xuICAgIGNvbnN0IGFmdGVyVGFza1N0b3JlID0gX2FmdGVydGFza2FzeW5jc3RvcmFnZWV4dGVybmFsLmFmdGVyVGFza0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIHJldHVybiAoYWZ0ZXJUYXNrU3RvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFmdGVyVGFza1N0b3JlLnJvb3RUYXNrU3Bhd25QaGFzZSkgPT09ICdhY3Rpb24nO1xufVxuY29uc3Qgd2VsbEtub3duUHJvcGVydGllcyA9IG5ldyBTZXQoW1xuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ3RvU3RyaW5nJyxcbiAgICAndmFsdWVPZicsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgJ3RoZW4nLFxuICAgICdjYXRjaCcsXG4gICAgJ2ZpbmFsbHknLFxuICAgIC8vIFJlYWN0IFByb21pc2UgZXh0ZW5zaW9uXG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICAnc3RhdHVzJyxcbiAgICAvLyBSZWFjdCBpbnRyb3NwZWN0aW9uXG4gICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICAvLyBDb21tb24gdGVzdGVkIHByb3BlcnRpZXNcbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgICd0b0pTT04nLFxuICAgICckJHR5cGVvZicsXG4gICAgJ19fZXNNb2R1bGUnXG5dKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5IiwiZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcyIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJ0aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yIiwidGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IiLCJ3ZWxsS25vd25Qcm9wZXJ0aWVzIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3N0YXRpY2dlbmVyYXRpb25iYWlsb3V0IiwicmVxdWlyZSIsIl9hZnRlcnRhc2thc3luY3N0b3JhZ2VleHRlcm5hbCIsImlzRGVmaW5pdGVseUFWYWxpZElkZW50aWZpZXIiLCJwcm9wIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdHJpbmdpZmllZFByb3AiLCJyb3V0ZSIsImV4cHJlc3Npb24iLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJhZnRlclRhc2tTdG9yZSIsImFmdGVyVGFza0FzeW5jU3RvcmFnZSIsImdldFN0b3JlIiwicm9vdFRhc2tTcGF3blBoYXNlIiwiU2V0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"ReflectAdapter\", ({\n  enumerable: true,\n  get: function () {\n    return ReflectAdapter;\n  }\n}));\nclass ReflectAdapter {\n  static get(target, prop, receiver) {\n    const value = Reflect.get(target, prop, receiver);\n    if (typeof value === 'function') {\n      return value.bind(target);\n    }\n    return value;\n  }\n  static set(target, prop, value, receiver) {\n    return Reflect.set(target, prop, value, receiver);\n  }\n  static has(target, prop) {\n    return Reflect.has(target, prop);\n  }\n  static deleteProperty(target, prop) {\n    return Reflect.deleteProperty(target, prop);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7RUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7RUFDN0NJLFVBQVUsRUFBRSxJQUFJO0VBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO0lBQ1osT0FBT0MsY0FBYztFQUN6QjtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1BLGNBQWMsQ0FBQztFQUNqQixPQUFPRCxHQUFHQSxDQUFDRSxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQy9CLE1BQU1OLEtBQUssR0FBR08sT0FBTyxDQUFDTCxHQUFHLENBQUNFLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLENBQUM7SUFDakQsSUFBSSxPQUFPTixLQUFLLEtBQUssVUFBVSxFQUFFO01BQzdCLE9BQU9BLEtBQUssQ0FBQ1EsSUFBSSxDQUFDSixNQUFNLENBQUM7SUFDN0I7SUFDQSxPQUFPSixLQUFLO0VBQ2hCO0VBQ0EsT0FBT1MsR0FBR0EsQ0FBQ0wsTUFBTSxFQUFFQyxJQUFJLEVBQUVMLEtBQUssRUFBRU0sUUFBUSxFQUFFO0lBQ3RDLE9BQU9DLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDTCxNQUFNLEVBQUVDLElBQUksRUFBRUwsS0FBSyxFQUFFTSxRQUFRLENBQUM7RUFDckQ7RUFDQSxPQUFPSSxHQUFHQSxDQUFDTixNQUFNLEVBQUVDLElBQUksRUFBRTtJQUNyQixPQUFPRSxPQUFPLENBQUNHLEdBQUcsQ0FBQ04sTUFBTSxFQUFFQyxJQUFJLENBQUM7RUFDcEM7RUFDQSxPQUFPTSxjQUFjQSxDQUFDUCxNQUFNLEVBQUVDLElBQUksRUFBRTtJQUNoQyxPQUFPRSxPQUFPLENBQUNJLGNBQWMsQ0FBQ1AsTUFBTSxFQUFFQyxJQUFJLENBQUM7RUFDL0M7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL2thc2hpZi5ha3JhbS9Qcm9qZWN0cy9uZXh0L21hbnVhbC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZmxlY3RBZGFwdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0QWRhcHRlcjtcbiAgICB9XG59KTtcbmNsYXNzIFJlZmxlY3RBZGFwdGVyIHtcbiAgICBzdGF0aWMgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIlJlZmxlY3RBZGFwdGVyIiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImJpbmQiLCJzZXQiLCJoYXMiLCJkZWxldGVQcm9wZXJ0eSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-page.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientPageRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientPageRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientPageRoot(param) {\n    let { Component, searchParams, params, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    promises } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js\");\n        let clientSearchParams;\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling searchParams in a client Page.');\n        }\n        const { createSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\");\n        clientSearchParams = createSearchParamsFromClient(searchParams, store);\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    } else {\n        const { createRenderSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js\");\n        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    }\n}\n_c = ClientPageRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"ClientPageRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiLCJtYXBwaW5ncyI6InFEQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGtEQUFpRDtJQUM3Q0ksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxjQUFjO0lBQ3pCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsV0FBVyxHQUFHQyxtQkFBTyxDQUFDLHFHQUFtQixDQUFDO0FBQ2hELE1BQU1DLGVBQWUsR0FBR0QsbUJBQU8sQ0FBQyxvSEFBa0MsQ0FBQztBQUNuRSx3QkFBd0JFLEtBQUssRUFBRTtJQUMzQixJQUFJLEVBQUVDLFNBQVMsRUFBRUMsWUFBWSxFQUFFQyxNQUFNLEVBQUU7SUFDdkNDLFFBQUFBLEVBQVUsR0FBR0osS0FBSztJQUNsQixJQUFJLE9BQU9LLE1BQU0sS0FBSyxXQUFXLEVBQUU7UUFDL0IsTUFBTSxFQUFFQyxnQkFBQUEsRUFBa0IsR0FBR1IsbUJBQU8sQ0FBQywrSUFBcUQsQ0FBQztRQUMzRixJQUFJUyxrQkFBa0I7UUFDdEIsSUFBSUMsWUFBWTtRQUNoQjtRQUNBO1FBQ0EsTUFBTUMsS0FBSyxHQUFHSCxnQkFBZ0IsQ0FBQ0ksUUFBUSxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDRCxLQUFLLEVBQUU7WUFDUixNQUFNLElBQUlWLGVBQWUsQ0FBQ1ksY0FBYyxDQUFDLDBFQUEwRSxDQUFDO1FBQ3hIO1FBQ0EsTUFBTSxFQUFFQyw0QkFBQUEsRUFBOEIsR0FBR2QsbUJBQU8sQ0FBQyx3SEFBb0MsQ0FBQztRQUN0RlMsa0JBQWtCLEdBQUdLLDRCQUE0QixDQUFDVixZQUFZLEVBQUVPLEtBQUssQ0FBQztRQUN0RSxNQUFNLEVBQUVJLHNCQUFBQSxFQUF3QixHQUFHZixtQkFBTyxDQUFDLDBHQUE2QixDQUFDO1FBQ3pFVSxZQUFZLEdBQUdLLHNCQUFzQixDQUFDVixNQUFNLEVBQUVNLEtBQUssQ0FBQztRQUNwRCxPQUFPLGVBQWUsQ0FBQyxFQUFFWixXQUFXLENBQUNpQixHQUFBQSxFQUFLYixTQUFTLEVBQUU7WUFDakRFLE1BQU0sRUFBRUssWUFBWTtZQUNwQk4sWUFBWSxFQUFFSztRQUNsQixDQUFDLENBQUM7SUFDTixDQUFDLE1BQU07UUFDSCxNQUFNLEVBQUVRLGtDQUFBQSxFQUFvQyxHQUFHakIsbUJBQU8sQ0FBQyx3SUFBNEMsQ0FBQztRQUNwRyxNQUFNUyxrQkFBa0IsR0FBR1Esa0NBQWtDLENBQUNiLFlBQVksQ0FBQztRQUMzRSxNQUFNLEVBQUVjLDRCQUFBQSxFQUE4QixHQUFHbEIsbUJBQU8sQ0FBQywwSEFBcUMsQ0FBQztRQUN2RixNQUFNVSxZQUFZLEdBQUdRLDRCQUE0QixDQUFDYixNQUFNLENBQUM7UUFDekQsT0FBTyxlQUFlLENBQUMsRUFBRU4sV0FBVyxDQUFDaUIsR0FBQUEsRUFBS2IsU0FBUyxFQUFFO1lBQ2pERSxNQUFNLEVBQUVLLFlBQVk7WUFDcEJOLFlBQVksRUFBRUs7UUFDbEIsQ0FBQyxDQUFDO0lBQ047QUFDSjtLQS9CU1gsY0FBY0E7QUFpQ3ZCLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUN5QixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU96QixPQUFPLENBQUN5QixPQUFPLEtBQUssUUFBUSxJQUFJekIsT0FBTyxDQUFDeUIsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPekIsT0FBTyxDQUFDeUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLNUIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ3lCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRXhCLEtBQUssRUFBRTtJQUFLLENBQUMsQ0FBQztJQUNyRUgsTUFBTSxDQUFDNkIsTUFBTSxDQUFDM0IsT0FBTyxDQUFDeUIsT0FBTyxFQUFFekIsT0FBTyxDQUFDO0lBQ3ZDNEIsTUFBTSxDQUFDNUIsT0FBTyxHQUFHQSxPQUFPLENBQUN5QixPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRQYWdlUm9vdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ2xpZW50UGFnZVJvb3Q7XG4gICAgfVxufSk7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9pbnZhcmlhbnRlcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvclwiKTtcbmZ1bmN0aW9uIENsaWVudFBhZ2VSb290KHBhcmFtKSB7XG4gICAgbGV0IHsgQ29tcG9uZW50LCBzZWFyY2hQYXJhbXMsIHBhcmFtcywgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHByb21pc2VzIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPSByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnKTtcbiAgICAgICAgbGV0IGNsaWVudFNlYXJjaFBhcmFtcztcbiAgICAgICAgbGV0IGNsaWVudFBhcmFtcztcbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIGluc3RydW1lbnQgdGhlIHNlYXJjaFBhcmFtcyBwcm9wIHdpdGggdHJhY2tpbmcgZm9yIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB3b3JrQXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGlmICghc3RvcmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBfaW52YXJpYW50ZXJyb3IuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHNlYXJjaFBhcmFtcyBpbiBhIGNsaWVudCBQYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudCB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcycpO1xuICAgICAgICBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcywgc3RvcmUpO1xuICAgICAgICBjb25zdCB7IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQgfSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpO1xuICAgICAgICBjbGllbnRQYXJhbXMgPSBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50KHBhcmFtcywgc3RvcmUpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShDb21wb25lbnQsIHtcbiAgICAgICAgICAgIHBhcmFtczogY2xpZW50UGFyYW1zLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiBjbGllbnRTZWFyY2hQYXJhbXNcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IH0gPSByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zLmJyb3dzZXInKTtcbiAgICAgICAgY29uc3QgY2xpZW50U2VhcmNoUGFyYW1zID0gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudChzZWFyY2hQYXJhbXMpO1xuICAgICAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJyk7XG4gICAgICAgIGNvbnN0IGNsaWVudFBhcmFtcyA9IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBwYXJhbXM6IGNsaWVudFBhcmFtcyxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogY2xpZW50U2VhcmNoUGFyYW1zXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LXBhZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkNsaWVudFBhZ2VSb290IiwiX2pzeHJ1bnRpbWUiLCJyZXF1aXJlIiwiX2ludmFyaWFudGVycm9yIiwicGFyYW0iLCJDb21wb25lbnQiLCJzZWFyY2hQYXJhbXMiLCJwYXJhbXMiLCJwcm9taXNlcyIsIndpbmRvdyIsIndvcmtBc3luY1N0b3JhZ2UiLCJjbGllbnRTZWFyY2hQYXJhbXMiLCJjbGllbnRQYXJhbXMiLCJzdG9yZSIsImdldFN0b3JlIiwiSW52YXJpYW50RXJyb3IiLCJjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUGFyYW1zRnJvbUNsaWVudCIsImpzeCIsImNyZWF0ZVJlbmRlclNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-segment.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientSegmentRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientSegmentRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientSegmentRoot(param) {\n    let { Component, slots, params, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    promise } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js\");\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling params in a client segment such as a Layout or Template.');\n        }\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    } else {\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    }\n}\n_c = ClientSegmentRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"ClientSegmentRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMiLCJtYXBwaW5ncyI6InFEQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHFEQUFvRDtJQUNoREksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxpQkFBaUI7SUFDNUI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxXQUFXLEdBQUdDLG1CQUFPLENBQUMscUdBQW1CLENBQUM7QUFDaEQsTUFBTUMsZUFBZSxHQUFHRCxtQkFBTyxDQUFDLG9IQUFrQyxDQUFDO0FBQ25FLDJCQUEyQkUsS0FBSyxFQUFFO0lBQzlCLElBQUksRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRTtJQUNoQ0MsT0FBQUEsRUFBUyxHQUFHSixLQUFLO0lBQ2pCLElBQUksT0FBT0ssTUFBTSxLQUFLLFdBQVcsRUFBRTtRQUMvQixNQUFNLEVBQUVDLGdCQUFBQSxFQUFrQixHQUFHUixtQkFBTyxDQUFDLCtJQUFxRCxDQUFDO1FBQzNGLElBQUlTLFlBQVk7UUFDaEI7UUFDQTtRQUNBLE1BQU1DLEtBQUssR0FBR0YsZ0JBQWdCLENBQUNHLFFBQVEsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQ0QsS0FBSyxFQUFFO1lBQ1IsTUFBTSxJQUFJVCxlQUFlLENBQUNXLGNBQWMsQ0FBQyxvR0FBb0csQ0FBQztRQUNsSjtRQUNBLE1BQU0sRUFBRUMsc0JBQUFBLEVBQXdCLEdBQUdiLG1CQUFPLENBQUMsMEdBQTZCLENBQUM7UUFDekVTLFlBQVksR0FBR0ksc0JBQXNCLENBQUNSLE1BQU0sRUFBRUssS0FBSyxDQUFDO1FBQ3BELE9BQU8sZUFBZSxDQUFDLEVBQUVYLFdBQVcsQ0FBQ2UsR0FBQUEsRUFBS1gsU0FBUyxFQUFFO1lBQ2pELEdBQUdDLEtBQUs7WUFDUkMsTUFBTSxFQUFFSTtRQUNaLENBQUMsQ0FBQztJQUNOLENBQUMsTUFBTTtRQUNILE1BQU0sRUFBRU0sNEJBQUFBLEVBQThCLEdBQUdmLG1CQUFPLENBQUMsMEhBQXFDLENBQUM7UUFDdkYsTUFBTVMsWUFBWSxHQUFHTSw0QkFBNEIsQ0FBQ1YsTUFBTSxDQUFDO1FBQ3pELE9BQU8sZUFBZSxDQUFDLEVBQUVOLFdBQVcsQ0FBQ2UsR0FBQUEsRUFBS1gsU0FBUyxFQUFFO1lBQ2pELEdBQUdDLEtBQUs7WUFDUkMsTUFBTSxFQUFFSTtRQUNaLENBQUMsQ0FBQztJQUNOO0FBQ0o7S0ExQlNYLGlCQUFpQkE7QUE0QjFCLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUNzQixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU90QixPQUFPLENBQUNzQixPQUFPLEtBQUssUUFBUSxJQUFJdEIsT0FBTyxDQUFDc0IsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPdEIsT0FBTyxDQUFDc0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLekIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ3NCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRXJCLEtBQUssRUFBRTtJQUFLLENBQUMsQ0FBQztJQUNyRUgsTUFBTSxDQUFDMEIsTUFBTSxDQUFDeEIsT0FBTyxDQUFDc0IsT0FBTyxFQUFFdEIsT0FBTyxDQUFDO0lBQ3ZDeUIsTUFBTSxDQUFDekIsT0FBTyxHQUFHQSxPQUFPLENBQUNzQixPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRTZWdtZW50Um9vdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ2xpZW50U2VnbWVudFJvb3Q7XG4gICAgfVxufSk7XG5jb25zdCBfanN4cnVudGltZSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IF9pbnZhcmlhbnRlcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvclwiKTtcbmZ1bmN0aW9uIENsaWVudFNlZ21lbnRSb290KHBhcmFtKSB7XG4gICAgbGV0IHsgQ29tcG9uZW50LCBzbG90cywgcGFyYW1zLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcHJvbWlzZSB9ID0gcGFyYW07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJyk7XG4gICAgICAgIGxldCBjbGllbnRQYXJhbXM7XG4gICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byBpbnN0cnVtZW50IHRoZSBzZWFyY2hQYXJhbXMgcHJvcCB3aXRoIHRyYWNraW5nIGZvciB0aGVcbiAgICAgICAgLy8gYXBwcm9wcmlhdGUgY29udGV4dC4gV2Ugd3JhcCBkaWZmZXJlbnRseSBpbiBwcmVyZW5kZXJpbmcgdnMgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IHN0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgX2ludmFyaWFudGVycm9yLkludmFyaWFudEVycm9yKCdFeHBlY3RlZCB3b3JrU3RvcmUgdG8gZXhpc3Qgd2hlbiBoYW5kbGluZyBwYXJhbXMgaW4gYSBjbGllbnQgc2VnbWVudCBzdWNoIGFzIGEgTGF5b3V0IG9yIFRlbXBsYXRlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlUGFyYW1zRnJvbUNsaWVudCB9ID0gcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJyk7XG4gICAgICAgIGNsaWVudFBhcmFtcyA9IGNyZWF0ZVBhcmFtc0Zyb21DbGllbnQocGFyYW1zLCBzdG9yZSk7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKENvbXBvbmVudCwge1xuICAgICAgICAgICAgLi4uc2xvdHMsXG4gICAgICAgICAgICBwYXJhbXM6IGNsaWVudFBhcmFtc1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJyk7XG4gICAgICAgIGNvbnN0IGNsaWVudFBhcmFtcyA9IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAuLi5zbG90cyxcbiAgICAgICAgICAgIHBhcmFtczogY2xpZW50UGFyYW1zXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LXNlZ21lbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkNsaWVudFNlZ21lbnRSb290IiwiX2pzeHJ1bnRpbWUiLCJyZXF1aXJlIiwiX2ludmFyaWFudGVycm9yIiwicGFyYW0iLCJDb21wb25lbnQiLCJzbG90cyIsInBhcmFtcyIsInByb21pc2UiLCJ3aW5kb3ciLCJ3b3JrQXN5bmNTdG9yYWdlIiwiY2xpZW50UGFyYW1zIiwic3RvcmUiLCJnZXRTdG9yZSIsIkludmFyaWFudEVycm9yIiwiY3JlYXRlUGFyYW1zRnJvbUNsaWVudCIsImpzeCIsImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _errorboundary1 = __webpack_require__(/*! ./http-access-fallback/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./router-reducer/reducers/has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                'refetch'\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (typeof window === 'undefined') return null;\n    // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n    // We need to lazily reference it.\n    const internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;\n    return internal_reactDOMfindDOMNode(instance);\n}\nconst rectProperties = [\n    'bottom',\n    'height',\n    'left',\n    'right',\n    'top',\n    'width',\n    'x',\n    'y'\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        'sticky',\n        'fixed'\n    ].includes(getComputedStyle(element).position)) {\n        if (true) {\n            console.warn('Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:', element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === 'top') {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args), this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        ;\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        // Scroll into view doesn't scroll horizontally by default when not needed\n                        ;\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant global layout router not mounted');\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey, url, childNodes, segmentPath, tree, // TODO-APP: implement `<Offscreen>` when available.\n    // isActive,\n    cacheKey } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant global layout router not mounted');\n    }\n    const { changeByServerResponse, tree: fullTree } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    if (childNode === undefined) {\n        const newLazyCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(),\n            loading: null\n        };\n        /**\n    * Flight data fetch kicked off during render and put into the cache.\n    */ childNode = newLazyCacheNode;\n        childNodes.set(cacheKey, newLazyCacheNode);\n    }\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `rsc`.\n    const rsc = (0, _react.useDeferredValue)(childNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function' ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        let lazyData = childNode.lazyData;\n        if (lazyData === null) {\n            /**\n      * Router state with refetch marker added\n      */ // TODO-APP: remove ''\n            const refetchTree = walkAddRefetch([\n                '',\n                ...segmentPath\n            ], fullTree);\n            const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);\n            childNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), {\n                flightRouterState: refetchTree,\n                nextUrl: includeNextUrl ? context.nextUrl : null\n            }).then((serverResponse)=>{\n                (0, _react.startTransition)(()=>{\n                    changeByServerResponse({\n                        previousTree: fullTree,\n                        serverResponse\n                    });\n                });\n                return serverResponse;\n            });\n        }\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n        (0, _react.use)(_unresolvedthenable.unresolvedThenable);\n    }\n    // If we get to this point, then we know we have something we can render.\n    const subtree = // The layout router context narrows down tree and childNodes at each level.\n    /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            loading: childNode.loading\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { loading, children } = param;\n    // If loading is a promise, unwrap it. This happens in cases where we haven't\n    // yet received the loading data from the server — which includes whether or\n    // not this layout has a loading component at all.\n    //\n    // It's OK to suspend here instead of inside the fallback because this\n    // promise will resolve simultaneously with the data for the segment itself.\n    // So it will never suspend for longer than it would have if we didn't use\n    // a Suspense fallback at all.\n    let loadingModuleData;\n    if (typeof loading === 'object' && loading !== null && typeof loading.then === 'function') {\n        const promiseForLoading = loading;\n        loadingModuleData = (0, _react.use)(promiseForLoading);\n    } else {\n        loadingModuleData = loading;\n    }\n    if (loadingModuleData) {\n        const loadingRsc = loadingModuleData[0];\n        const loadingStyles = loadingModuleData[1];\n        const loadingScripts = loadingModuleData[2];\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loadingRsc\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw new Error('invariant expected layout router to be mounted');\n    }\n    const { childNodes, tree, url, loading } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\n  * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n  */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: preservedSegments.map((preservedSegment)=>{\n            const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n            return(/*\n        - Error boundary\n        - Only renders error boundary if error component is provided.\n        - Rendered for each segment to ensure they have their own error state.\n        - Loading boundary\n        - Only renders suspense boundary if loading components is provided.\n        - Rendered for each segment to ensure they have their own loading state.\n        - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n        */ /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n                value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {\n                    segmentPath: segmentPath,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                        errorComponent: error,\n                        errorStyles: errorStyles,\n                        errorScripts: errorScripts,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                            loading: loading,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {\n                                notFound: notFound,\n                                forbidden: forbidden,\n                                unauthorized: unauthorized,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_redirectboundary.RedirectBoundary, {\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                        parallelRouterKey: parallelRouterKey,\n                                        url: url,\n                                        tree: tree,\n                                        childNodes: childNodesForParallelRouter,\n                                        segmentPath: segmentPath,\n                                        cacheKey: cacheKey,\n                                        isActive: currentChildSegmentValue === preservedSegmentValue\n                                    })\n                                })\n                            })\n                        })\n                    })\n                }),\n                children: [\n                    templateStyles,\n                    templateScripts,\n                    template\n                ]\n            }, (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true)));\n        })\n    });\n}\n_c3 = OuterLayoutRouter;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoicURBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBR2U7SUFDWEksVUFBVSxFQUFFLElBQUk7SUFDaEJDLEdBQUcsRUFBRSxTQUFBQSxDQUFBLEVBQVc7UUFDWixPQUFPQyxpQkFBaUI7SUFDNUI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyx3QkFBd0IsR0FBR0MsbUJBQU8sQ0FBQyxnSUFBeUMsQ0FBQztBQUNuRixNQUFNQyx5QkFBeUIsR0FBR0QsbUJBQU8sQ0FBQyxrSUFBMEMsQ0FBQztBQUNyRixNQUFNRSxXQUFXLEdBQUdGLG1CQUFPLENBQUMscUdBQW1CLENBQUM7TUFDMUNHLE1BQU0sR0FBRyxjQUFjRix5QkFBeUIsQ0FBQ0csQ0FBQyxDQUFDSixtQkFBTyxDQUFDLG1GQUFPLENBQUMsQ0FBQztBQUMxRSxNQUFNSyxTQUFTLEdBQUcsY0FBY04sd0JBQXdCLENBQUNLLENBQUMsQ0FBQ0osbUJBQU8sQ0FBQywyRkFBVyxDQUFDLENBQUM7QUFDaEYsTUFBTU0sOEJBQThCLEdBQUdOLG1CQUFPLENBQUMsd0pBQW9ELENBQUM7QUFDcEcsTUFBTU8sb0JBQW9CLEdBQUdQLG1CQUFPLENBQUMsc0pBQXdDLENBQUM7QUFDOUUsTUFBTVEsbUJBQW1CLEdBQUdSLG1CQUFPLENBQUMsb0hBQXVCLENBQUM7QUFDNUQsTUFBTVMsY0FBYyxHQUFHVCxtQkFBTyxDQUFDLDBHQUFrQixDQUFDO0FBQ2xELE1BQU1VLGNBQWMsR0FBR1YsbUJBQU8sQ0FBQywwR0FBa0IsQ0FBQztBQUNsRCxNQUFNVyxtQkFBbUIsR0FBR1gsbUJBQU8sQ0FBQyx3SkFBb0QsQ0FBQztBQUN6RixNQUFNWSxpQkFBaUIsR0FBR1osbUJBQU8sQ0FBQyxnSEFBcUIsQ0FBQztBQUN4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LE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRW5DLEtBQUssRUFBRTtJQUFLLENBQUMsQ0FBQztJQUNyRUgsTUFBTSxDQUFDb0wsTUFBTSxDQUFDbEwsT0FBTyxDQUFDb0MsT0FBTyxFQUFFcEMsT0FBTyxDQUFDO0lBQ3ZDbUwsTUFBTSxDQUFDbkwsT0FBTyxHQUFHQSxPQUFPLENBQUNvQyxPQUFPO0FBQ2xDIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAvKipcbiAqIE91dGVyTGF5b3V0Um91dGVyIGhhbmRsZXMgdGhlIGN1cnJlbnQgc2VnbWVudCBhcyB3ZWxsIGFzIDxPZmZzY3JlZW4+IHJlbmRlcmluZyBvZiBvdGhlciBzZWdtZW50cy5cbiAqIEl0IGNhbiBiZSByZW5kZXJlZCBuZXh0IHRvIGVhY2ggb3RoZXIgd2l0aCBhIGRpZmZlcmVudCBgcGFyYWxsZWxSb3V0ZXJLZXlgLCBhbGxvd2luZyBmb3IgUGFyYWxsZWwgcm91dGVzLlxuICovIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT3V0ZXJMYXlvdXRSb3V0ZXI7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3JlYWN0ZG9tID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX3VucmVzb2x2ZWR0aGVuYWJsZSA9IHJlcXVpcmUoXCIuL3VucmVzb2x2ZWQtdGhlbmFibGVcIik7XG5jb25zdCBfZXJyb3Jib3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xuY29uc3QgX21hdGNoc2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5jb25zdCBfcmVkaXJlY3Rib3VuZGFyeSA9IHJlcXVpcmUoXCIuL3JlZGlyZWN0LWJvdW5kYXJ5XCIpO1xuY29uc3QgX2Vycm9yYm91bmRhcnkxID0gcmVxdWlyZShcIi4vaHR0cC1hY2Nlc3MtZmFsbGJhY2svZXJyb3ItYm91bmRhcnlcIik7XG5jb25zdCBfZ2V0c2VnbWVudHZhbHVlID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWVcIik7XG5jb25zdCBfY3JlYXRlcm91dGVyY2FjaGVrZXkgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbmNvbnN0IF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZVwiKTtcbi8qKlxuICogQWRkIHJlZmV0Y2ggbWFya2VyIHRvIHJvdXRlciBzdGF0ZSBhdCB0aGUgcG9pbnQgb2YgdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKiBUaGlzIGVuc3VyZXMgdGhlIHJlc3BvbnNlIHJldHVybmVkIGlzIG5vdCBmdXJ0aGVyIGRvd24gdGhhbiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqLyBmdW5jdGlvbiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2FsaywgdHJlZVRvUmVjcmVhdGUpIHtcbiAgICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gc2VnbWVudFBhdGhUb1dhbGs7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKCgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHRyZWVUb1JlY3JlYXRlWzBdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRyZWVUb1JlY3JlYXRlWzFdLmhhc093blByb3BlcnR5KHBhcmFsbGVsUm91dGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gd2Fsa0FkZFJlZmV0Y2godW5kZWZpbmVkLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udHJlZVRvUmVjcmVhdGVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IHdhbGtBZGRSZWZldGNoKHNlZ21lbnRQYXRoVG9XYWxrLnNsaWNlKDIpLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyZWVUb1JlY3JlYXRlO1xufVxuY29uc3QgX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID0gX3JlYWN0ZG9tLmRlZmF1bHQuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuLy8gVE9ETy1BUFA6IFJlcGxhY2Ugd2l0aCBuZXcgUmVhY3QgQVBJIGZvciBmaW5kaW5nIGRvbSBub2RlcyB3aXRob3V0IGEgYHJlZmAgd2hlbiBhdmFpbGFibGVcbi8qKlxuICogV3JhcHMgUmVhY3RET00uZmluZERPTU5vZGUgd2l0aCBhZGRpdGlvbmFsIGxvZ2ljIHRvIGhpZGUgUmVhY3QgU3RyaWN0IE1vZGUgd2FybmluZ1xuICovIGZ1bmN0aW9uIGZpbmRET01Ob2RlKGluc3RhbmNlKSB7XG4gICAgLy8gVHJlZS1zaGFrZSBmb3Igc2VydmVyIGJ1bmRsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gICAgLy8gX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLmZpbmRET01Ob2RlIGlzIG51bGwgZHVyaW5nIG1vZHVsZSBpbml0LlxuICAgIC8vIFdlIG5lZWQgdG8gbGF6aWx5IHJlZmVyZW5jZSBpdC5cbiAgICBjb25zdCBpbnRlcm5hbF9yZWFjdERPTWZpbmRET01Ob2RlID0gX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLmZpbmRET01Ob2RlO1xuICAgIHJldHVybiBpbnRlcm5hbF9yZWFjdERPTWZpbmRET01Ob2RlKGluc3RhbmNlKTtcbn1cbmNvbnN0IHJlY3RQcm9wZXJ0aWVzID0gW1xuICAgICdib3R0b20nLFxuICAgICdoZWlnaHQnLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICd0b3AnLFxuICAgICd3aWR0aCcsXG4gICAgJ3gnLFxuICAgICd5J1xuXTtcbi8qKlxuICogQ2hlY2sgaWYgYSBIVE1MRWxlbWVudCBpcyBoaWRkZW4gb3IgZml4ZWQvc3RpY2t5IHBvc2l0aW9uXG4gKi8gZnVuY3Rpb24gc2hvdWxkU2tpcEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8vIHdlIGlnbm9yZSBmaXhlZCBvciBzdGlja3kgcG9zaXRpb25lZCBlbGVtZW50cyBzaW5jZSB0aGV5J2xsIGxpa2VseSBwYXNzIHRoZSBcImluLXZpZXdwb3J0XCIgY2hlY2tcbiAgICAvLyBhbmQgd2lsbCByZXN1bHQgaW4gYSBzaXR1YXRpb24gd2UgYmFpbCBvbiBzY3JvbGwgYmVjYXVzZSBvZiBzb21ldGhpbmcgbGlrZSBhIGZpeGVkIG5hdixcbiAgICAvLyBldmVuIHRob3VnaCB0aGUgYWN0dWFsIHBhZ2UgY29udGVudCBpcyBvZmZzY3JlZW5cbiAgICBpZiAoW1xuICAgICAgICAnc3RpY2t5JyxcbiAgICAgICAgJ2ZpeGVkJ1xuICAgIF0uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NraXBwaW5nIGF1dG8tc2Nyb2xsIGJlaGF2aW9yIGR1ZSB0byBgcG9zaXRpb246IHN0aWNreWAgb3IgYHBvc2l0aW9uOiBmaXhlZGAgb24gZWxlbWVudDonLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVXNlcyBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gaW5zdGVhZCBvZiBgb2Zmc2V0UGFyZW50YFxuICAgIC8vIGJlY2F1c2UgYG9mZnNldFBhcmVudGAgZG9lc24ndCBjb25zaWRlciBkb2N1bWVudC9ib2R5XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3RQcm9wZXJ0aWVzLmV2ZXJ5KChpdGVtKT0+cmVjdFtpdGVtXSA9PT0gMCk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b3AgY29ybmVyIG9mIHRoZSBIVE1MRWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gKi8gZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50LCB2aWV3cG9ydEhlaWdodCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0LnRvcCA+PSAwICYmIHJlY3QudG9wIDw9IHZpZXdwb3J0SGVpZ2h0O1xufVxuLyoqXG4gKiBGaW5kIHRoZSBET00gbm9kZSBmb3IgYSBoYXNoIGZyYWdtZW50LlxuICogSWYgYHRvcGAgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLiBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIncyBiZWhhdmlvci5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGFuIGlkLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBlbGVtZW50IHdpdGggdGhhdCBpZC5cbiAqIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGEgbmFtZSwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoYXQgbmFtZS5cbiAqLyBmdW5jdGlvbiBnZXRIYXNoRnJhZ21lbnREb21Ob2RlKGhhc2hGcmFnbWVudCkge1xuICAgIC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5cbiAgICBpZiAoaGFzaEZyYWdtZW50ID09PSAndG9wJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgdmFyIF9kb2N1bWVudF9nZXRFbGVtZW50QnlJZDtcbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gICAgcmV0dXJuIChfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoRnJhZ21lbnQpKSAhPSBudWxsID8gX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkIDogLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYSBuYW1lLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggdGhhdCBuYW1lLlxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2hGcmFnbWVudClbMF07XG59XG5jbGFzcyBJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIHByb3BlcnR5IGlzIG92ZXJ3cml0dGVuIGluIGhhbmRsZVBvdGVudGlhbFNjcm9sbCBpdCdzIGZpbmUgdG8gYWx3YXlzIHJ1biBpdCB3aGVuIHRydWUgYXMgaXQnbGwgYmUgc2V0IHRvIGZhbHNlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKSwgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwgPSAoKT0+e1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNjcm9sbCBhbmQgZm9jdXMsIGl0J3Mgb25seSBhcHBsaWVkIG9uY2UgaW4gdGhlIGZpcnN0IHVzZUVmZmVjdCB0aGF0IHRyaWdnZXJzIHRoYXQgY2hhbmdlZC5cbiAgICAgICAgICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYsIHNlZ21lbnRQYXRoIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudFBhdGhzIGlzIGFuIGFycmF5IG9mIHNlZ21lbnQgcGF0aHMgdGhhdCBzaG91bGQgYmUgc2Nyb2xsZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHBhdGggaXMgbm90IGluIHRoZSBhcnJheSwgdGhlIHNjcm9sbCBpcyBub3QgYXBwbGllZFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGUgYXJyYXkgaXMgZW1wdHksIGluIHdoaWNoIGNhc2UgdGhlIHNjcm9sbCBpcyBhbHdheXMgYXBwbGllZFxuICAgICAgICAgICAgICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMubGVuZ3RoICE9PSAwICYmICFmb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMuc29tZSgoc2Nyb2xsUmVmU2VnbWVudFBhdGgpPT5zZWdtZW50UGF0aC5ldmVyeSgoc2VnbWVudCwgaW5kZXgpPT4oMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZWdtZW50LCBzY3JvbGxSZWZTZWdtZW50UGF0aFtpbmRleF0pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaEZyYWdtZW50ID0gZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYGZpbmRET01Ob2RlYCBpcyB0cmlja3kgYmVjYXVzZSBpdCByZXR1cm5zIGp1c3QgdGhlIGZpcnN0IGNoaWxkIGlmIHRoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscmVhZHkgY2F1c2VkIGEgYnVnIHdoZXJlIHRoZSBmaXJzdCBjaGlsZCB3YXMgYSA8bGluay8+IGluIGhlYWQuXG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NIG5vZGUgdGhpcyBsYXlvdXQtcm91dGVyIGxldmVsIGlzIHNraXBwZWQuIEl0J2xsIGJlIGhhbmRsZWQgaGlnaGVyLXVwIGluIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgIGlmICghKGRvbU5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZWxlbWVudCBpcyBhIEhUTUxFbGVtZW50IGFuZCBpZiB3ZSB3YW50IHRvIGNvbnNpZGVyIGl0IGZvciBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2tpcHBlZCwgdHJ5IHRvIHNlbGVjdCB0aGUgbmV4dCBzaWJsaW5nIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgd2hpbGUoIShkb21Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8IHNob3VsZFNraXBFbGVtZW50KGRvbU5vZGUpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc2libGluZ3MgZm91bmQgdGhhdCBtYXRjaCB0aGUgY3JpdGVyaWEgYXJlIGZvdW5kLCBzbyBoYW5kbGUgc2Nyb2xsIGhpZ2hlciB1cCBpbiB0aGUgdHJlZSBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIG11dGF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZvY3VzIGFuZCBzY3JvbGwgaXMgYXBwbGllZCBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBoYXNoIHNjcm9sbCwgd2Ugb25seSBuZWVkIHRvIHNjcm9sbCB0aGUgZWxlbWVudCBpbnRvIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGhlaWdodCBiZWNhdXNlIHJlYWRpbmcgYGNsaWVudEhlaWdodGAgY2F1c2VzIGEgcmVmbG93LFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBodG1sRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50J3MgdG9wIGVkZ2UgaXMgYWxyZWFkeSBpbiB0aGUgdmlld3BvcnQsIGV4aXQgZWFybHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBjYWxsZWQgb24gYDxodG1sLz5gIGVsZW1lbnQgc2Nyb2xscyBob3Jpem9udGFsbHkgb24gY2hyb21lIGFuZCBmaXJlZm94ICh0aGF0IHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gZG9tTm9kZSBpZiBkb21Ob2RlIGlzIG5vdCBpbiB2aWV3cG9ydCB3aGVuIHNjcm9sbGVkIHRvIHRvcCBvZiBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGwgaW50byB2aWV3IGRvZXNuJ3Qgc2Nyb2xsIGhvcml6b250YWxseSBieSBkZWZhdWx0IHdoZW4gbm90IG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGZvcmNlIGxheW91dCBieSBxdWVyeWluZyBkb21Ob2RlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGRvbnRGb3JjZUxheW91dDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb25seUhhc2hDaGFuZ2U6IGZvY3VzQW5kU2Nyb2xsUmVmLm9ubHlIYXNoQ2hhbmdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTXV0YXRlIGFmdGVyIHNjcm9sbGluZyBzbyB0aGF0IGl0IGNhbiBiZSByZWFkIGJ5IGBoYW5kbGVTbW9vdGhTY3JvbGxgXG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBkb21Ob2RlLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gU2Nyb2xsQW5kRm9jdXNIYW5kbGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgc2VnbWVudFBhdGgsIGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKElubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGNvbnRleHQuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuLyoqXG4gKiBJbm5lckxheW91dFJvdXRlciBoYW5kbGVzIHJlbmRlcmluZyB0aGUgcHJvdmlkZWQgc2VnbWVudCBiYXNlZCBvbiB0aGUgY2FjaGUuXG4gKi8gZnVuY3Rpb24gSW5uZXJMYXlvdXRSb3V0ZXIocGFyYW0pIHtcbiAgICBsZXQgeyBwYXJhbGxlbFJvdXRlcktleSwgdXJsLCBjaGlsZE5vZGVzLCBzZWdtZW50UGF0aCwgdHJlZSwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuICAgIC8vIGlzQWN0aXZlLFxuICAgIGNhY2hlS2V5IH0gPSBwYXJhbTtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSwgdHJlZTogZnVsbFRyZWUgfSA9IGNvbnRleHQ7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICAvLyBXaGVuIGRhdGEgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2hcbiAgICAvLyBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNoaWxkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5ld0xhenlDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBsb2FkaW5nOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCBkYXRhIGZldGNoIGtpY2tlZCBvZmYgZHVyaW5nIHJlbmRlciBhbmQgcHV0IGludG8gdGhlIGNhY2hlLlxuICAgICAqLyBjaGlsZE5vZGUgPSBuZXdMYXp5Q2FjaGVOb2RlO1xuICAgICAgICBjaGlsZE5vZGVzLnNldChjYWNoZUtleSwgbmV3TGF6eUNhY2hlTm9kZSk7XG4gICAgfVxuICAgIC8vIGByc2NgIHJlcHJlc2VudHMgdGhlIHJlbmRlcmFibGUgbm9kZSBmb3IgdGhpcyBzZWdtZW50LlxuICAgIC8vIElmIHRoaXMgc2VnbWVudCBoYXMgYSBgcHJlZmV0Y2hSc2NgLCBpdCdzIHRoZSBzdGF0aWNhbGx5IHByZWZldGNoZWQgZGF0YS5cbiAgICAvLyBXZSBzaG91bGQgdXNlIHRoYXQgb24gaW5pdGlhbCByZW5kZXIgaW5zdGVhZCBvZiBgcnNjYC4gVGhlbiB3ZSdsbCBzd2l0Y2hcbiAgICAvLyB0byBgcnNjYCB3aGVuIHRoZSBkeW5hbWljIHJlc3BvbnNlIHN0cmVhbXMgaW4uXG4gICAgLy9cbiAgICAvLyBJZiBubyBwcmVmZXRjaCBkYXRhIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgYHJzY2AuXG4gICAgY29uc3QgcmVzb2x2ZWRQcmVmZXRjaFJzYyA9IGNoaWxkTm9kZS5wcmVmZXRjaFJzYyAhPT0gbnVsbCA/IGNoaWxkTm9kZS5wcmVmZXRjaFJzYyA6IGNoaWxkTm9kZS5yc2M7XG4gICAgLy8gV2UgdXNlIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBoYW5kbGUgc3dpdGNoaW5nIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kXG4gICAgLy8gZmluYWwgdmFsdWVzLiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHJldHVybmVkIG9uIGluaXRpYWwgcmVuZGVyLCB0aGVuIGl0XG4gICAgLy8gcmUtcmVuZGVycyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAvL1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhlIHNlY29uZCBhcmd1bWVudCB0byBgdXNlRGVmZXJyZWRWYWx1ZWAgaXMgb25seVxuICAgIC8vIGF2YWlsYWJsZSBpbiB0aGUgZXhwZXJpbWVudGFsIGJ1aWxkcy4gV2hlbiBpdHMgZGlzYWJsZWQsIGl0IHdpbGwgYWx3YXlzXG4gICAgLy8gcmV0dXJuIGByc2NgLlxuICAgIGNvbnN0IHJzYyA9ICgwLCBfcmVhY3QudXNlRGVmZXJyZWRWYWx1ZSkoY2hpbGROb2RlLnJzYywgcmVzb2x2ZWRQcmVmZXRjaFJzYyk7XG4gICAgLy8gYHJzY2AgaXMgZWl0aGVyIGEgUmVhY3Qgbm9kZSBvciBhIHByb21pc2UgZm9yIGEgUmVhY3Qgbm9kZSwgZXhjZXB0IHdlXG4gICAgLy8gc3BlY2lhbCBjYXNlIGBudWxsYCB0byByZXByZXNlbnQgdGhhdCB0aGlzIHNlZ21lbnQncyBkYXRhIGlzIG1pc3NpbmcuIElmXG4gICAgLy8gaXQncyBhIHByb21pc2UsIHdlIG5lZWQgdG8gdW53cmFwIGl0IHNvIHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlXG4gICAgLy8gZGF0YSBpcyBtaXNzaW5nLlxuICAgIGNvbnN0IHJlc29sdmVkUnNjID0gdHlwZW9mIHJzYyA9PT0gJ29iamVjdCcgJiYgcnNjICE9PSBudWxsICYmIHR5cGVvZiByc2MudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/ICgwLCBfcmVhY3QudXNlKShyc2MpIDogcnNjO1xuICAgIGlmICghcmVzb2x2ZWRSc2MpIHtcbiAgICAgICAgLy8gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudCBpcyBub3QgYXZhaWxhYmxlLCBhbmQgdGhlcmUncyBubyBwZW5kaW5nXG4gICAgICAgIC8vIG5hdmlnYXRpb24gdGhhdCB3aWxsIGJlIGFibGUgdG8gZnVsZmlsbCBpdC4gV2UgbmVlZCB0byBmZXRjaCBtb3JlIGZyb21cbiAgICAgICAgLy8gdGhlIHNlcnZlciBhbmQgcGF0Y2ggdGhlIGNhY2hlLlxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHJlcXVlc3QuXG4gICAgICAgIGxldCBsYXp5RGF0YSA9IGNoaWxkTm9kZS5sYXp5RGF0YTtcbiAgICAgICAgaWYgKGxhenlEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgY29uc3QgcmVmZXRjaFRyZWUgPSB3YWxrQWRkUmVmZXRjaChbXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgICAgIF0sIGZ1bGxUcmVlKTtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gKDAsIF9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUuaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKShmdWxsVHJlZSk7XG4gICAgICAgICAgICBjaGlsZE5vZGUubGF6eURhdGEgPSBsYXp5RGF0YSA9ICgwLCBfZmV0Y2hzZXJ2ZXJyZXNwb25zZS5mZXRjaFNlcnZlclJlc3BvbnNlKShuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKSwge1xuICAgICAgICAgICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiByZWZldGNoVHJlZSxcbiAgICAgICAgICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IGNvbnRleHQubmV4dFVybCA6IG51bGxcbiAgICAgICAgICAgIH0pLnRoZW4oKHNlcnZlclJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVhY3Quc3RhcnRUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJlZTogZnVsbFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyUmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdXNwZW5kIGluZmluaXRlbHkgYXMgYGNoYW5nZUJ5U2VydmVyUmVzcG9uc2VgIHdpbGwgY2F1c2UgYSBkaWZmZXJlbnQgcGFydCBvZiB0aGUgdHJlZSB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgLy8gQSBmYWxzZXkgYHJlc29sdmVkUnNjYCBpbmRpY2F0ZXMgbWlzc2luZyBkYXRhIC0tIHdlIHNob3VsZCBub3QgY29tbWl0IHRoYXQgYnJhbmNoLCBhbmQgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZGF0YSB0byBhcnJpdmUuXG4gICAgICAgICgwLCBfcmVhY3QudXNlKShfdW5yZXNvbHZlZHRoZW5hYmxlLnVucmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgfVxuICAgIC8vIElmIHdlIGdldCB0byB0aGlzIHBvaW50LCB0aGVuIHdlIGtub3cgd2UgaGF2ZSBzb21ldGhpbmcgd2UgY2FuIHJlbmRlci5cbiAgICBjb25zdCBzdWJ0cmVlID0gLy8gVGhlIGxheW91dCByb3V0ZXIgY29udGV4dCBuYXJyb3dzIGRvd24gdHJlZSBhbmQgY2hpbGROb2RlcyBhdCBlYWNoIGxldmVsLlxuICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgbG9hZGluZzogY2hpbGROb2RlLmxvYWRpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IHJlc29sdmVkUnNjXG4gICAgfSk7XG4gICAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gICAgcmV0dXJuIHN1YnRyZWU7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgbG9hZGluZywgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIC8vIElmIGxvYWRpbmcgaXMgYSBwcm9taXNlLCB1bndyYXAgaXQuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyB3aGVyZSB3ZSBoYXZlbid0XG4gICAgLy8geWV0IHJlY2VpdmVkIHRoZSBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc2VydmVyIOKAlCB3aGljaCBpbmNsdWRlcyB3aGV0aGVyIG9yXG4gICAgLy8gbm90IHRoaXMgbGF5b3V0IGhhcyBhIGxvYWRpbmcgY29tcG9uZW50IGF0IGFsbC5cbiAgICAvL1xuICAgIC8vIEl0J3MgT0sgdG8gc3VzcGVuZCBoZXJlIGluc3RlYWQgb2YgaW5zaWRlIHRoZSBmYWxsYmFjayBiZWNhdXNlIHRoaXNcbiAgICAvLyBwcm9taXNlIHdpbGwgcmVzb2x2ZSBzaW11bHRhbmVvdXNseSB3aXRoIHRoZSBkYXRhIGZvciB0aGUgc2VnbWVudCBpdHNlbGYuXG4gICAgLy8gU28gaXQgd2lsbCBuZXZlciBzdXNwZW5kIGZvciBsb25nZXIgdGhhbiBpdCB3b3VsZCBoYXZlIGlmIHdlIGRpZG4ndCB1c2VcbiAgICAvLyBhIFN1c3BlbnNlIGZhbGxiYWNrIGF0IGFsbC5cbiAgICBsZXQgbG9hZGluZ01vZHVsZURhdGE7XG4gICAgaWYgKHR5cGVvZiBsb2FkaW5nID09PSAnb2JqZWN0JyAmJiBsb2FkaW5nICE9PSBudWxsICYmIHR5cGVvZiBsb2FkaW5nLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZUZvckxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICBsb2FkaW5nTW9kdWxlRGF0YSA9ICgwLCBfcmVhY3QudXNlKShwcm9taXNlRm9yTG9hZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGluZ01vZHVsZURhdGEgPSBsb2FkaW5nO1xuICAgIH1cbiAgICBpZiAobG9hZGluZ01vZHVsZURhdGEpIHtcbiAgICAgICAgY29uc3QgbG9hZGluZ1JzYyA9IGxvYWRpbmdNb2R1bGVEYXRhWzBdO1xuICAgICAgICBjb25zdCBsb2FkaW5nU3R5bGVzID0gbG9hZGluZ01vZHVsZURhdGFbMV07XG4gICAgICAgIGNvbnN0IGxvYWRpbmdTY3JpcHRzID0gbG9hZGluZ01vZHVsZURhdGFbMl07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9yZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NjcmlwdHMsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdSc2NcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5mdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcihwYXJhbSkge1xuICAgIGxldCB7IHBhcmFsbGVsUm91dGVyS2V5LCBzZWdtZW50UGF0aCwgZXJyb3IsIGVycm9yU3R5bGVzLCBlcnJvclNjcmlwdHMsIHRlbXBsYXRlU3R5bGVzLCB0ZW1wbGF0ZVNjcmlwdHMsIHRlbXBsYXRlLCBub3RGb3VuZCwgZm9yYmlkZGVuLCB1bmF1dGhvcml6ZWQgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGROb2RlcywgdHJlZSwgdXJsLCBsb2FkaW5nIH0gPSBjb250ZXh0O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBwYXJhbGxlbFJvdXRlciBjYWNoZSBub2RlXG4gICAgbGV0IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICAvLyBJZiB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuXG4gICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgaWYgKCFjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpIHtcbiAgICAgICAgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gbmV3IE1hcCgpO1xuICAgICAgICBjaGlsZE5vZGVzLnNldChwYXJhbGxlbFJvdXRlcktleSwgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBhY3RpdmUgc2VnbWVudCBpbiB0aGUgdHJlZVxuICAgIC8vIFRoZSByZWFzb24gYXJyYXlzIGFyZSB1c2VkIGluIHRoZSBkYXRhIGZvcm1hdCBpcyB0aGF0IHRoZXNlIGFyZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGJyb3dzZXIgc28gaXQncyBvcHRpbWl6ZWQgdG8gc2F2ZSBieXRlcy5cbiAgICBjb25zdCB0cmVlU2VnbWVudCA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldWzBdO1xuICAgIC8vIElmIHNlZ21lbnQgaXMgYW4gYXJyYXkgaXQncyBhIGR5bmFtaWMgcm91dGUgYW5kIHdlIHdhbnQgdG8gcmVhZCB0aGUgZHluYW1pYyByb3V0ZSB2YWx1ZSBhcyB0aGUgc2VnbWVudCB0byBnZXQgZnJvbSB0aGUgY2FjaGUuXG4gICAgY29uc3QgY3VycmVudENoaWxkU2VnbWVudFZhbHVlID0gKDAsIF9nZXRzZWdtZW50dmFsdWUuZ2V0U2VnbWVudFZhbHVlKSh0cmVlU2VnbWVudCk7XG4gICAgLyoqXG4gICAqIERlY2lkZXMgd2hpY2ggc2VnbWVudHMgdG8ga2VlcCByZW5kZXJpbmcsIGFsbCBzZWdtZW50cyB0aGF0IGFyZSBub3QgYWN0aXZlIHdpbGwgYmUgd3JhcHBlZCBpbiBgPE9mZnNjcmVlbj5gLlxuICAgKi8gLy8gVE9ETy1BUFA6IEFkZCBoYW5kbGluZyBvZiBgPE9mZnNjcmVlbj5gIHdoZW4gaXQncyBhdmFpbGFibGUuXG4gICAgY29uc3QgcHJlc2VydmVkU2VnbWVudHMgPSBbXG4gICAgICAgIHRyZWVTZWdtZW50XG4gICAgXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfanN4cnVudGltZS5GcmFnbWVudCwge1xuICAgICAgICBjaGlsZHJlbjogcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgcHJlc2VydmVkU2VnbWVudFZhbHVlID0gKDAsIF9nZXRzZWdtZW50dmFsdWUuZ2V0U2VnbWVudFZhbHVlKShwcmVzZXJ2ZWRTZWdtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkocHJlc2VydmVkU2VnbWVudCk7XG4gICAgICAgICAgICByZXR1cm4oLypcbiAgICAgICAgICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAgICAgICAgICovIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShTY3JvbGxBbmRGb2N1c0hhbmRsZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfZXJyb3Jib3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudDogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclN0eWxlczogZXJyb3JTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclNjcmlwdHM6IGVycm9yU2NyaXB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKExvYWRpbmdCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2Vycm9yYm91bmRhcnkxLkhUVFBBY2Nlc3NGYWxsYmFja0JvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yYmlkZGVuOiBmb3JiaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuYXV0aG9yaXplZDogdW5hdXRob3JpemVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfcmVkaXJlY3Rib3VuZGFyeS5SZWRpcmVjdEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbm5lckxheW91dFJvdXRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVyS2V5OiBwYXJhbGxlbFJvdXRlcktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUgPT09IHByZXNlcnZlZFNlZ21lbnRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVTY3JpcHRzLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sICgwLCBfY3JlYXRlcm91dGVyY2FjaGVrZXkuY3JlYXRlUm91dGVyQ2FjaGVLZXkpKHByZXNlcnZlZFNlZ21lbnQsIHRydWUpKSk7XG4gICAgICAgIH0pXG4gICAgfSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIk91dGVyTGF5b3V0Um91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVhY3Rkb20iLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfZmV0Y2hzZXJ2ZXJyZXNwb25zZSIsIl91bnJlc29sdmVkdGhlbmFibGUiLCJfZXJyb3Jib3VuZGFyeSIsIl9tYXRjaHNlZ21lbnRzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsIl9yZWRpcmVjdGJvdW5kYXJ5IiwiX2Vycm9yYm91bmRhcnkxIiwiX2dldHNlZ21lbnR2YWx1ZSIsIl9jcmVhdGVyb3V0ZXJjYWNoZWtleSIsIl9oYXNpbnRlcmNlcHRpb25yb3V0ZWluY3VycmVudHRyZWUiLCJ3YWxrQWRkUmVmZXRjaCIsInNlZ21lbnRQYXRoVG9XYWxrIiwidHJlZVRvUmVjcmVhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwiZGVmYXVsdCIsImZpbmRET01Ob2RlIiwiaW5zdGFuY2UiLCJ3aW5kb3ciLCJpbnRlcm5hbF9yZWFjdERPTWZpbmRET01Ob2RlIiwicmVjdFByb3BlcnRpZXMiLCJzaG91bGRTa2lwRWxlbWVudCIsImVsZW1lbnQiLCJpbmNsdWRlcyIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnNvbGUiLCJ3YXJuIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImV2ZXJ5IiwiaXRlbSIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJ2aWV3cG9ydEhlaWdodCIsInRvcCIsImdldEhhc2hGcmFnbWVudERvbU5vZGUiLCJoYXNoRnJhZ21lbnQiLCJkb2N1bWVudCIsImJvZHkiLCJfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiSW5uZXJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRNb3VudCIsImhhbmRsZVBvdGVudGlhbFNjcm9sbCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByb3BzIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsInJlbmRlciIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJhcmdzIiwic2VnbWVudFBhdGgiLCJzZWdtZW50UGF0aHMiLCJzb21lIiwic2Nyb2xsUmVmU2VnbWVudFBhdGgiLCJpbmRleCIsImRvbU5vZGUiLCJFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxJbnRvVmlldyIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwiZG9udEZvcmNlTGF5b3V0Iiwib25seUhhc2hDaGFuZ2UiLCJmb2N1cyIsIlNjcm9sbEFuZEZvY3VzSGFuZGxlciIsInBhcmFtIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJqc3giLCJJbm5lckxheW91dFJvdXRlciIsInBhcmFsbGVsUm91dGVyS2V5IiwidXJsIiwiY2hpbGROb2RlcyIsInRyZWUiLCJjYWNoZUtleSIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImNoaWxkTm9kZSIsIm5ld0xhenlDYWNoZU5vZGUiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwibG9hZGluZyIsInNldCIsInJlc29sdmVkUHJlZmV0Y2hSc2MiLCJ1c2VEZWZlcnJlZFZhbHVlIiwicmVzb2x2ZWRSc2MiLCJ0aGVuIiwidXNlIiwicmVmZXRjaFRyZWUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInNlcnZlclJlc3BvbnNlIiwic3RhcnRUcmFuc2l0aW9uIiwicHJldmlvdXNUcmVlIiwidW5yZXNvbHZlZFRoZW5hYmxlIiwic3VidHJlZSIsIkxheW91dFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIkxvYWRpbmdCb3VuZGFyeSIsImxvYWRpbmdNb2R1bGVEYXRhIiwicHJvbWlzZUZvckxvYWRpbmciLCJsb2FkaW5nUnNjIiwibG9hZGluZ1N0eWxlcyIsImxvYWRpbmdTY3JpcHRzIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsImpzeHMiLCJGcmFnbWVudCIsImVycm9yIiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlU2NyaXB0cyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJmb3JiaWRkZW4iLCJ1bmF1dGhvcml6ZWQiLCJjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIiLCJ0cmVlU2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnRWYWx1ZSIsImdldFNlZ21lbnRWYWx1ZSIsInByZXNlcnZlZFNlZ21lbnRzIiwibWFwIiwicHJlc2VydmVkU2VnbWVudCIsInByZXNlcnZlZFNlZ21lbnRWYWx1ZSIsImNyZWF0ZVJvdXRlckNhY2hlS2V5IiwiVGVtcGxhdGVDb250ZXh0IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiSFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwiaXNBY3RpdmUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return RenderFromTemplateContext;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nfunction RenderFromTemplateContext() {\n    const children = (0, _react.useContext)(_approutercontextsharedruntime.TemplateContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n}\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyIsIm1hcHBpbmdzIjoicURBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUNaLE9BQU9DLHlCQUF5QjtJQUNwQztBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLHlCQUF5QixHQUFHQyxtQkFBTyxDQUFDLGtJQUEwQyxDQUFDO0FBQ3JGLE1BQU1DLFdBQVcsR0FBR0QsbUJBQU8sQ0FBQyxxR0FBbUIsQ0FBQztBQUNoRCxNQUFNRSxNQUFNLEdBQUcsY0FBY0gseUJBQXlCLENBQUNJLENBQUMsQ0FBQ0gsbUJBQU8sQ0FBQyxtRkFBTyxDQUFDLENBQUM7QUFDMUUsTUFBTUksOEJBQThCLEdBQUdKLG1CQUFPLENBQUMsd0pBQW9ELENBQUM7QUFDcEc7SUFDSSxNQUFNSyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEVBQUVILE1BQU0sQ0FBQ0ksVUFBQUEsRUFBWUYsOEJBQThCLENBQUNHLGVBQWUsQ0FBQztJQUN2RixPQUFPLGVBQWUsQ0FBQyxFQUFFTixXQUFXLENBQUNPLEdBQUFBLEVBQUtQLFdBQVcsQ0FBQ1EsUUFBUSxFQUFFO1FBQzVESixRQUFRLEVBQUVBO0lBQ2QsQ0FBQyxDQUFDO0FBQ047S0FMU1AseUJBQXlCQSxDQUFBO0FBT2xDLElBQUksQ0FBQyxPQUFPSixPQUFPLENBQUNnQixPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU9oQixPQUFPLENBQUNnQixPQUFPLEtBQUssUUFBUSxJQUFJaEIsT0FBTyxDQUFDZ0IsT0FBTyxLQUFLLEtBQUssSUFBSyxPQUFPaEIsT0FBTyxDQUFDZ0IsT0FBTyxDQUFDQyxVQUFVLEtBQUssV0FBVyxFQUFFO0lBQ3JLbkIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sQ0FBQ2dCLE9BQU8sRUFBRSxZQUFZLEVBQUU7UUFBRWYsS0FBSyxFQUFFO0lBQUssQ0FBQyxDQUFDO0lBQ3JFSCxNQUFNLENBQUNvQixNQUFNLENBQUNsQixPQUFPLENBQUNnQixPQUFPLEVBQUVoQixPQUFPLENBQUM7SUFDdkNtQixNQUFNLENBQUNuQixPQUFPLEdBQUdBLE9BQU8sQ0FBQ2dCLE9BQU87QUFDbEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmZ1bmN0aW9uIFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJqc3giLCJGcmFnbWVudCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/invariant-error.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"InvariantError\", ({\n    enumerable: true,\n    get: function() {\n        return InvariantError;\n    }\n}));\nclass InvariantError extends Error {\n    constructor(message, options){\n        super(\"Invariant: \" + (message.endsWith('.') ? message : message + '.') + \" This is a bug in Next.js.\", options);\n        this.name = 'InvariantError';\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUU7QUFDWCxDQUFDLEVBQUM7QUFDRkgsa0RBQWlEO0lBQzdDSSxVQUFVLEVBQUUsSUFBSTtJQUNoQkMsR0FBRyxFQUFFLFNBQUFBLENBQUEsRUFBVztRQUNaLE9BQU9DLGNBQWM7SUFDekI7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQSxjQUFjLFNBQVNDLEtBQUssQ0FBQztJQUMvQkMsV0FBV0EsQ0FBQ0MsT0FBTyxFQUFFQyxPQUFPLENBQUM7UUFDekIsS0FBSyxDQUFDLGFBQWEsSUFBSUQsT0FBTyxDQUFDRSxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUdGLE9BQU8sR0FBR0EsT0FBTyxHQUFHLElBQUcsQ0FBQyxFQUFHLDRCQUE0QixFQUFFQyxPQUFPLENBQUM7UUFDaEgsSUFBSSxDQUFDRSxJQUFJLEdBQUcsZ0JBQWdCO0lBQ2hDO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rYXNoaWYuYWtyYW0vUHJvamVjdHMvbmV4dC9tYW51YWwvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ludmFyaWFudC1lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFyaWFudEVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbnZhcmlhbnRFcnJvcjtcbiAgICB9XG59KTtcbmNsYXNzIEludmFyaWFudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihcIkludmFyaWFudDogXCIgKyAobWVzc2FnZS5lbmRzV2l0aCgnLicpID8gbWVzc2FnZSA6IG1lc3NhZ2UgKyAnLicpICsgXCIgVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzLlwiLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFyaWFudEVycm9yJztcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFyaWFudC1lcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSW52YXJpYW50RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdGlvbnMiLCJlbmRzV2l0aCIsIm5hbWUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSmoothScroll\", ({\n    enumerable: true,\n    get: function() {\n        return handleSmoothScroll;\n    }\n}));\nfunction handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = 'auto';\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdBLEdBQWlCO0FBQ2pCQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRTtBQUNYLENBQUMsRUFBQztBQUNGSCxzREFBcUQ7SUFDakRJLFVBQVUsRUFBRSxJQUFJO0lBQ2hCQyxHQUFHLEVBQUUsU0FBQUEsQ0FBQSxFQUFXO1FBQ1osT0FBT0Msa0JBQWtCO0lBQzdCO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0Esa0JBQWtCQSxDQUFDQyxFQUFFLEVBQUVDLE9BQU8sRUFBRTtJQUNyQyxJQUFJQSxPQUFPLEtBQUssS0FBSyxDQUFDLEVBQUVBLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDcEM7SUFDQTtJQUNBLElBQUlBLE9BQU8sQ0FBQ0MsY0FBYyxFQUFFO1FBQ3hCRixFQUFFLENBQUMsQ0FBQztRQUNKO0lBQ0o7SUFDQSxNQUFNRyxXQUFXLEdBQUdDLFFBQVEsQ0FBQ0MsZUFBZTtJQUM1QyxNQUFNQyxRQUFRLEdBQUdILFdBQVcsQ0FBQ0ksS0FBSyxDQUFDQyxjQUFjO0lBQ2pETCxXQUFXLENBQUNJLEtBQUssQ0FBQ0MsY0FBYyxHQUFHLE1BQU07SUFDekMsSUFBSSxDQUFDUCxPQUFPLENBQUNRLGVBQWUsRUFBRTtRQUMxQjtRQUNBO1FBQ0E7UUFDQU4sV0FBVyxDQUFDTyxjQUFjLENBQUMsQ0FBQztJQUNoQztJQUNBVixFQUFFLENBQUMsQ0FBQztJQUNKRyxXQUFXLENBQUNJLEtBQUssQ0FBQ0MsY0FBYyxHQUFHRixRQUFRO0FBQy9DIiwic291cmNlcyI6WyIvVXNlcnMva2FzaGlmLmFrcmFtL1Byb2plY3RzL25leHQvbWFudWFsL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSdW4gZnVuY3Rpb24gd2l0aCBgc2Nyb2xsLWJlaGF2aW9yOiBhdXRvYCBhcHBsaWVkIHRvIGA8aHRtbC8+YC5cbiAqIFRoaXMgY3NzIGNoYW5nZSB3aWxsIGJlIHJldmVydGVkIGFmdGVyIHRoZSBmdW5jdGlvbiBmaW5pc2hlcy5cbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhbmRsZVNtb290aFNjcm9sbFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU21vb3RoU2Nyb2xsO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gaGFuZGxlU21vb3RoU2Nyb2xsKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIC8vIGlmIG9ubHkgdGhlIGhhc2ggaXMgY2hhbmdlZCwgd2UgZG9uJ3QgbmVlZCB0byBkaXNhYmxlIHNtb290aCBzY3JvbGxpbmdcbiAgICAvLyB3ZSBvbmx5IGNhcmUgdG8gcHJldmVudCBzbW9vdGggc2Nyb2xsaW5nIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlIHRvIGF2b2lkIGphcnJpbmcgVVhcbiAgICBpZiAob3B0aW9ucy5vbmx5SGFzaENoYW5nZSkge1xuICAgICAgICBmbigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0byc7XG4gICAgaWYgKCFvcHRpb25zLmRvbnRGb3JjZUxheW91dCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUtYmFzZWQgYnJvd3NlcnMgd2UgbmVlZCB0byBmb3JjZSByZWZsb3cgYmVmb3JlIGNhbGxpbmcgYHNjcm9sbFRvYC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgbm90IHBpY2t1cCB0aGUgY2hhbmdlIGluIHNjcm9sbEJlaGF2aW9yXG4gICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQwNzE5I2lzc3VlY29tbWVudC0xMzM2MjQ4MDQyXG4gICAgICAgIGh0bWxFbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgfVxuICAgIGZuKCk7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlLXNtb290aC1zY3JvbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhbmRsZVNtb290aFNjcm9sbCIsImZuIiwib3B0aW9ucyIsIm9ubHlIYXNoQ2hhbmdlIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImRvbnRGb3JjZUxheW91dCIsImdldENsaWVudFJlY3RzIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fkashif.akram%2FProjects%2Fnext%2Fmanual%2Fnode_modules%2Fnext%2Fdist%2Flib%2Fmetadata%2Fmetadata-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);